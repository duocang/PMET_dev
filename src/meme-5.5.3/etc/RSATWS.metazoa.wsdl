<?xml version="1.0" encoding ='UTF-8' ?>
<?xml-stylesheet type="text/xsl" href="RSATWS.xsl"?>
<definitions name="RSATWS"
	     targetNamespace="urn:RSATWS"
             xmlns:tns="urn:RSATWS"
             xmlns:xsd="http://www.w3.org/2001/XMLSchema"
             xmlns="http://schemas.xmlsoap.org/wsdl/"
	     xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
	     xmlns:html="http://www.w3.org/1999/xhtml"
	     xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <types>
    <xsd:schema targetNamespace="urn:RSATWS" xmlns="http://www.w3.org/2001/XMLSchema" xmlns:xsd="http://www.w3.org/2001/XMLSchema">

      <!-- RSA TOOLS REQUESTS -->
      <xsd:complexType name="RetrieveSequenceRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation retrieve_seq.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="organism" type="xsd:string" minOccurs="1">
            <xsd:annotation>
              <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="query" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>A list of query genes.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Return sequences for all the genes of the organism if value = 1. Incompatible with query.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="noorf" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Prevent overlap with upstream open reading frames (ORF) if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="from" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Inferior limit of the region to retrieve.
Default is organism dependant (example: Saccharomyces cerevisiae = -800).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="to" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Superior limit of the region to retrieve. Default is '-1'.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="feattype" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Type of genome features to load. Supported: CDS, mRNA, tRNA, rRNA. </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="type" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation> Sequence type. Supported: upstream, downstream, ORF (unspliced open reading frame).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Sequence format. Supported: IG (Intelligenetics), WC (wconsensus), raw, FastA</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="lw" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Line width (0 for whole sequence on one line).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="label" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Field(s) to be used in the sequence label. Multiple fields can be specified, separated by commas. 
Supported: id, name, organism_name, sequence_type, current_from, current_to, ctg, orf_strand, reg_left, reg_right. 
Default: name.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="label_sep" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Separator between the label fields. Default: | (pipe character).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="nocom" type="xsd:int" minOccurs="0">
           <xsd:annotation>
              <xsd:documentation>No comments if value = 1. Only the identifier and the sequence are returned. 
By default, the comment indicates the ORF and upstream sequence coordinates.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="repeat" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Use the repeat masked version of the genome if value = 1.
Warning: repeated regions are annotated for some genomes only.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="imp_pos" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Admit imprecise positions if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RetrieveSequenceMultigenomeRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation retrieve_seq_multigenome.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="input" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>The input file is a tab-delimited text files with (at least) the two following columns:
    1. gene ID or name
      Identifier oor synonyms are supported.
    2. Organism name
      For the organism name, spaces must be replaced by underscore character
      (exactly as for retrieve-seq).
    If additional columns are included in the input file, they are ignored.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="tmp_input_file" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Input file on the server.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Return sequences for all the genes of the organism if value = 1. Incompatible with query.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="noorf" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Prevent overlap with upstream open reading frames (ORF) if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="from" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Inferior limit of the region to retrieve. Default is organism dependant (example: Saccharomyces cerevisiae = -800).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="to" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Superior limit of the region to retrieve. Default is '-1'.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="feattype" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Type of genome features to load. Supported: CDS, mRNA, tRNA, rRNA. </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="type" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation> Sequence type. Supported: upstream, downstream, ORF (unspliced open reading frame).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Sequence format. Supported: IG (Intelligenetics), WC (wconsensus), raw, FastA</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="lw" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Line width (0 for whole sequence on one line).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="label" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Field(s) to be used in the sequence label. Multiple fields can be specified, separated by commas. 
Supported: id, name, organism_name, sequence_type, current_from, current_to, ctg, orf_strand, reg_left, reg_right. 
Default: name.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="label_sep" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Separator between the label fields. Default: | (pipe character).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="nocom" type="xsd:int" minOccurs="0">
           <xsd:annotation>
              <xsd:documentation>No comments if value = 1. Only the identifier and the sequence are returned. 
By default, the comment indicates the ORF and upstream sequence coordinates.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="repeat" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Use the repeat masked version of the genome if value = 1. Attention: repeated regions are annotated for some genomes only.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="imp_pos" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Admit imprecise positions if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="gene_col" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Number of the column containing the gene names/identifiers (default: 1).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="org_col" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Number of the column containing the organisms (default: 2).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RetrieveEnsemblSequenceRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation retrieve_ensembl_seq.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="organism" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="ensembl_host" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Address of ensembl database server (default is EBI server).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="db_name" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Name of EnsEMBL database (alternative to organism).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="query" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>A list of query genes. You need to supply either this parameter or the next one (tmp_infile).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation> Name of the file with list of genes on the server. You need to supply either this parameter or the previous one (query).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Return sequences for all the genes of the organism if value = 1. Incompatible with query.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="noorf" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Prevent overlap with upstream open reading frames (ORF) if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="nogene" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Prevent overlap with upstream gene (extreme transcripts limits) if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="from" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Inferior limit of the region to retrieve. Default is organism dependant (example: Saccharomyces cerevisiae = -800).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="to" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Superior limit of the region to retrieve. Default is '-1'.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="feattype" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Type of genome features to load. Supported: Gene, CDS, mRNA, intron, exon. </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="type" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation> Sequence type. Supported: upstream, downstream.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="chromosome" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Chromosome name or number (to use with -left and -right).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="left" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Left limit of sequence to retrieve.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="right" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Right limit of sequence to retrieve.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="strand" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Strand of sequence to retrieve when using -left and -right. Values: 1, -1</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="features" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Features.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="feat_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Features format. Supported: ft, gft</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="mask_coding" type="xsd:int" minOccurs="0">
           <xsd:annotation>
              <xsd:documentation>All coding sequence is replaced by N in the retrieved sequence if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="repeat" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Use the repeat masked version of the genome if value = 1. Attention: repeated regions are annotated for some genomes only.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="all_transcripts" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Get sequences for all transcript of genes if value = 1. Combine with unique_sequences option if you do pattern discovery afterwards.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="unique_sequences" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>When getting sequences for all transcripts of genes, keep only non-redundant fragments if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="first_intron" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>With feattype intron, get only first intron sequence if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="non_coding" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>With feattype exon, get only non-coding (part of) exons if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="utr" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>With feattype UTR, get only 5prime or 3prime UTR (default is all UTRs).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="line_width" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>A newline character will be inserted in the sequence every ## bases. 0 will prevent newline insertion. This is the default value</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="ortho" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Get orthologuous sequences if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="taxon" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Filter on taxonomic level when collecting orthologs (e.g. Murinae)</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="homology_type" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Filter on homology type when collecting orthologs (e.g. ortholog_one2one)</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="header_organism" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Type of organism name to use in the fasta header (scientific, common or none).
 Default is scientific. Common name is only accessible with -ortho.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="PurgeSequenceRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation purge_sequence.</xsd:documentation>
        </xsd:annotation>
       <xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sequence" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Sequence to purge. You need to supply either this parameter or the next one (tmp_infile).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation> Name of the file with input sequence on the server. You need to supply either this parameter or the previous one (sequence).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Sequence format. Supported: IG (Intelligenetics), WC (wconsensus), raw, FastA.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="match_length" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Minimal match length. Default is 40.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="mismatch" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of mismatches allowed. Default is 3.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="str" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Discard duplications on the direct strand only (1) or on the reverse complement as well (2). Default is 2.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="delete" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Delete repeats instead of masking them if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="mask_short" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Mask (replace by N characters) sequences shorter than the specified length.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
       </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="OligoAnalysisRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation oligo_analysis.</xsd:documentation>
        </xsd:annotation>
       	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="verbosity" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Verbosity.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sequence" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input sequence. You need to supply either this parameter or the next one (tmp_infile).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with input sequence on the server. You need to supply either this parameter or the previous one (sequence).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input sequence format. Supported: IG (Intelligenetics), WC (wconsensus), raw, fasta. Default is fasta.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="length" type="xsd:int" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Oligomer length.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="organism" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Background model: Type of sequences used as background model for estimating expected oligonucleotide frequencies. 
Supported: upstream, upstream-noorf, upstream-noorf-rm, intergenic, input.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="stats" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>List of statistics to return. Supported:occ, mseq, freq, proba, ratio, zscore, like, pos, rank.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="noov" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>No overlapping of oligos allowed if value = 1.
Disable the detection of overlapping matches for self-overlapping patterns (ex TATATA, GATAGA).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="str" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Oligonucleotide occurrences found on both stands are summed (2) or not (1). Default is 2.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sort" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Sort oligomers according to overrepresentation if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>Lower threshold on some parameters. Format=list of'parameter value'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="uth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>Upper threshold on some parameters. Format=list of 'parameter value'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="pseudo" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Pseudo-weight. Must be a real value between 0 and 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="OligoDiffRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation oligo_diff.</xsd:documentation>
        </xsd:annotation>
       	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="verbosity" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Verbosity.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="test" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input test sequence in fasta format. You need to supply either this parameter or the next one (tmp_test_infile).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_test_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with input test sequence on the server. You need to supply either this parameter or the previous one (test).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="control" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input control sequence in fasta format. You need to supply either this parameter or the next one (tmp_control_infile).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_control_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with input control sequence on the server. You need to supply either this parameter or the previous one (control).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="side" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Side of the significance test (values: test, ctrl, both). In practice, the side is converted into a threshold on the ratio test/control occurences.
	      test: only tests over-representation in the test sequences. This is converted into a lower threshold of 1 for the test/control ratio
	      both: test over-representation in eitherr the test or the control set
	      ctrl: only tests over-representation in the control sequences. This is converted into a upper thrshold of 1 for the test/control ratio.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="nopurge" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Do not purge input sequences before counting oligonucleotide occurences if value = 1.
Input sequences are purged by default, as this is highly recommended since redundant sequence fragments bias the overrepresentation statistics and create false positives</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="length" type="xsd:int" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Oligomer length.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="noov" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>No overlapping of oligos allowed if value = 1.
Disable the detection of overlapping matches for self-overlapping patterns (ex TATATA, GATAGA).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="str" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Oligonucleotide occurrences found on both stands are summed (2) or not (1). Default is 2.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>Lower threshold on some parameters. Format=list of'parameter value'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="uth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>Upper threshold on some parameters. Format=list of 'parameter value'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="PeakMotifsRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation chip_motifs.</xsd:documentation>
        </xsd:annotation>
       	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="verbosity" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Verbosity.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="test" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input test peak sequence in fasta format. You need to supply either this parameter or the next one (tmp_test_infile).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_test_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with input test peak sequence on the server. You need to supply either this parameter or the previous one (test).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="control" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input control peak sequence in fasta format. You can supply either this parameter or the next one (tmp_control_infile) or none.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_control_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with input control peak sequence on the server. You can supply either this parameter or the previous one (control) or none.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="max_seq_length" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximal sequence length.
Larger sequences  are truncated  at the specified length around the sequence center (from -value/2 to value/2)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="max_motif_number" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximal number of motifs (matrices) to return for pattern discovery algorithms.
Note the distinction between the maximal number of motifs (matrices) and the maximum number of patterns (words, dyads): a motif generally corresponds to mutually overlapping several patterns (dyads, words).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ref_motif" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Reference motif.
In some cases, we already dispose of a reference motif, for example the motif annotated in some transcription factor database (e.g. RegulonDB, Jaspar, TRANSFAC) for the transcription factor of interest. These annotations may come from low-throughput experiments, and rely on a poor number of sites, but the reference motif may nevertheless be informative, because it is based on several independent studies.
Each discovered motif can be compared to the reference motif, in order to evaluate its correspondence with the binding motif of the factor of interest.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="motif_db" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of motif database.
List of databases of transcription factor binding motifs (e.g. JASPAR, TRANSFAC, RegulonDB, ...) which will be compared to the discovered motifs (task motifs_vs_db). Use supported-motif-databases for availability</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="top_peaks" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Restrict the analysis to the N peaks at the top of the input sequence file. Some peak calling programs return the peaks sorted by
score. In such case, the -top_peaks option allows to restrict the analysis to the highest scoring peaks. In some cases, the top-scoring peaks might contain a higher density of binding sites,
allowing to detect motifs with a higher significance.
This option can also be convenient for performing quick tests, parameter selection and debugging before running the full analysis of large sequence sets.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="min_length" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Minimal oligonucleotide length. Use in combination with the next option (max_length).
If those options are used, the program iterates over the specified range of oligonucleotide lengths.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="max_length" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximal oligonucleotide length. Use in combination with the previous option (min_length).
If those options are used, the program iterates over the specified range of oligonucleotide lengths.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="markov" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Order of the Markov model used to estimatd expected oligonucleotide frequencies for oligo-analysis and local-word-analysis.
Higher order Markov models are more stringent, lower order are more sensitive, but tend to return a large number of false positives.
Markov models can be specified with either a positive or a negative value. Positive value indicate the length of the prefix in the transition matrix. Negative value indicate the order of the Markov model relative to the oligonucleotide length. For example, the option -markov -2 gives a model of order m=k-2 (thus, an order 5 for heptanucleotides, an order 4 for hexanucleotides).
The optimal Markov order depends on the number of sequences in the test set. Since ChIP-seq data typically contain hundreds to thoursands of peaks, high Markov orders are generally good, because they are stringent and still sensitive enough. In our experience, motifs are well detected with the most stringent Markov order (-markov -2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="min_markov" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Minimal value for markov order. Use in combination with the next option (max_markov).
If those options are used, the program iterates over the specified range of markov orders.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="max_markov" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximal value for markov order. Use in combination with the previous option (min_markov).
If those options are used, the program iterates over the specified range of markov orders.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="noov" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>No overlapping of oligos allowed if value = 1.
Disable the detection of overlapping matches for self-overlapping patterns (ex TATATA, GATAGA).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="class_int" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Class interval for position-analysis. The width of the position classes, in number of bases (default: 20)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="str" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Oligonucleotide occurrences found on both stands are summed (2) or not (1). Default is 2.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="graph_title" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Title displayed on top of the graphs.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="image_format" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Image format.
All the formats supported by XYgraph can be used.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="disco" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>oligos|dyads|positions|local_words|merged_words|meme|chipmunk
Specify the software tool(s) that will be used for motif discovery.
Several algorithms can be specified either by using the option iteratively:
	-disco oligos -disco dyads
or by entering a comma-separated list of algorithms:
	-disco oligos,dyads

Default motif discovery algorithms
  oligos: Run oligo-analysis to detect over-represented oligonucleotides of a given length (k, specified with option -l) in the test set (van Helden et al., 1998). Prior frequencies of oligonucleotides are taken from Markov model of order m (see option -markov) estimated from the test set sequences themselves.
  dyads: Run dyad-analysis to detect over-represented dyads, i.e. pairs of short oligonucleotides (monads) spaced by a region of fixed width but variable content (van Helden et al., 2000). Spaced motifs are typical of certain classes of transcription factors forming homo- or heterodimers. By default, chip-seq-analysis analyzes pairs of trinucleotides with any spacing between 0 and 20. The expected frequency of each dyad is estimated as the product of its monad frequencies in the input sequences (option -bg monads of dyad-analysis).
  positions: Run position-analysis to detect oligonucleotides showing a positional bias, i.e. have a non-homogeneous distribution in the peak sequence set.
	This method was initially developed to analyze termination and poly-adenylation signals in downstream sequences (van Helden et al., 2001), and it turns out to be very efficient for detecting motifs centred on the ChIP-seq peaks. For ChIP-seq analysis, the reference position is the center of each sequence.
	Note that chip-seq-analysis also uses position-analysis for the task profiles, in order to detect compositional biases (residues, dinucleotides) in the test sequence set.
  local_words: Run local-word-analysis to detect locally over-represented oligonucleotides and dyads.
	The program local-word-analysis (Matthieu Defrance,unpublished) tests the over-representation of each possible word (oligo, dyad) in positional windows in the input sequence set.
	Two types of background models are supported: (i) Markov model of order m estimated locally (within the window under consideration; (ii) the frequency observed for a word in the whole sequence set is used as estimator of the prior probability of this word in the window.
	After our first trials, this program gives excellent results in ChIP-seq datasets, because its senstivitity increases with large number of sequences (several hundreds/thousands), and its background model is more stringent than for programs computing the global over-representation (oligo-analysis, dyad-analysis).
  merged_words: Extract a position-specific scoring matrix (using matrix-from-patterns) from all the words discovered by the selected string-based motif disovery algorithms (oigos,dyads,positions and/or local_words).
	      </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="source" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Enter the source of the fasta sequence file.
Supported source: galaxy
When the sequence file comes from Galaxy, peak coordinates embedded in the fasta headers are extracted and used to convert predicted site coordinates (relative to peak center) to genomic coordinates (in the form of a bed file), which can then be uploaded to the UCSC genome browser as an annotation track.
This option is incompatible with -coord.
	      </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="task" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a subset of tasks to be executed.
By default, the program runs all necessary tasks. However, in some cases, it can be useful to select one or several tasks to be executed separately.
Beware: task selection requires expertise, because most tasks depends on the prior execution of some other tasks in the workflow. Selecting tasks before their prerequisite tasks have been completed will provoke fatal errors.
Available Tasks:
  all (default): Run all supported tasks.
  purge: Purge input sequences (test set and, if specified, control set) to mask redundant fragments before applying pattern discovery algorithms. Sequence purging is necessary because redundant fragments would violate the hypothesis of independence underlying the binomial significance test, resulting in a large number of false positive patterns.
  seqlen: Compute sequence lengths and their distribution. Sequence lengths are useful for the negative control (selection of random genome fragments). Sequence length distribution is informative to get an idea about the variability of peak lengths.
  composition: Compute compositional profiles, i.e. distributions of residues and dinucleotide frequencies per position (using position-analysis).
	Residue profiles may reveal composition biases in the neighborhood of the peak sequences. Dinucleotide profiles can reveal (for example) an enrichment in CpG island.
	Note that peak-motifs also runs position-analysis with larger oligonucleotide length (see option -l) to detect motifs on the basis of positionally biased oligonucleotides (see task positions).
  ref_motifs: This task combines various operations.
	Formating of the reference motif
          Perform various format conversion for the reference motif (compute parameters, consensus, logo).
	Motif enrichment
          Generate an enriched motif by scanning the peak sequence set with the reference motif.
	Motif comparison
	  Compare all discovered motifs with the reference motif.
  disco: Run the motif discovery algorithms. See option -disco for the selection of motif discovery algorithm(s).
  merge_words: Merge the words (oligos or dyads) discovered by the different string-based motif discovery algorithms.
	The table of merged words has one row per word (oligo or dyad) and one column per motif discovery program. This table is convenient to analyze the consistency between the words detected by different approaches, e.g. show that a word is both over-represented (oligo-analysis, dyad-analysis) and positionally biased (position-analysis, local-words). A heatmap is also exported to provide a graphical representation of the significance of each word (row) for each algorthm (column).
	The merged words can optionally be used as seeds for extracting position-specific scoring matrices from the sequences, using the program matrix-from-patterns (see option -disco merged_words).
  motif_compa: Motifs are compared in three ways.
	Discovered versus discovered (task cluster_motifs)
        Perform pairwise comparisons between all motifs (matrices) discovered by the different algorithms, to assess their consistency.
  motifs_vs_ref:
	Compare each discovered motif to the reference motif.
  motifs_vs_db:
	Compare each discovered motif to a database of known motifs (e.g. Jaspar, TRANSFAC, RegulonDB, UniProbe, ...)
  timelog: Generate a log file summarizing the time spent in the different tasks.
  synthesis: Generate the HTML file providing a synthesis of the results and pointing towards the individual result files.
  clean_seq: Delete the purged sequence files after the analysis, in order to save space. This task is executed only when it is called explicitly. It is not part of the tasks running with the option "-task all".</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="DyadAnalysisRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation dyad_analysis.</xsd:documentation>
        </xsd:annotation>
       	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="verbosity" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Verbosity.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sequence" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input sequence. You need to supply either this parameter or the next one (tmp_infile).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with input sequence on the server. 
You need to supply either this parameter or the previous one (sequence).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input sequence format. Supported: IG (Intelligenetics), WC (wconsensus), raw, fasta. Default is fasta.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="length" type="xsd:int" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Dyad length.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="spacing" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Spacing between elements of the dyads.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="organism" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Background model: Type of sequences used as background model for estimating expected oligonucleotide frequencies. 
Supported: upstream, upstreamL, upstream-noorf, intergenic, input.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="stats" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>List of statistics to return. Supported: occ, mseq, freq, proba, ratio, zscore, like, pos, rank.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="type" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>dyad_type (dr | ir | rep | any) 
In order to fasten execution, the program can be asked to restrict its analysis to symmetric dyads. 
Four types are accepted: 
	dr - direct repeats: the second element is the same as the first one; 
	ir - inverted repeats: the second element is the revers complement of the first one; 
	rep - repeats: direct and inverted repeats are evaluated. 
	any - (default) 
When selecting the option any, the analysis is performed on all non-symmetric dyads as well.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="noov" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>No overlapping of dyads allowed if value = 1. 
Disable the detection of overlapping matches for self-overlapping patterns (ex TATATA, GATAGA).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="str" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Dyad occurrences found on both stands are summed (2) or not (1). Default is 2.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sort" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Sort dyads according to overrepresentation if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="under" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Detect under-represented instead of over-represented dyads (left tail significance test) if value = 1.</xsd:documentation>
	  </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="two_tails" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Detect under-represented and over-represented dyads (two-fail significance test) if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="zeroocc" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Report also dyads with zero occurrences (provided they fit the other thresholds) if value = 1. 
By default, the program reports only patterns present in the sequence. 
If the left tail or two-tail test is applied, patterns with zero occurrences are automatically taken into account. 
In some other cases, one would also like to detect patterns absent from the sequence. 
This is the function of the option -zeroocc.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>Lower threshold on some parameters. Format=list of 'parameter value'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="uth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>Upper threshold on some parameter. Format=list of 'parameter value'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="PositionAnalysisRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation position_analysis.</xsd:documentation>
        </xsd:annotation>
       	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="verbosity" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Verbosity.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sequence" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input sequence. You need to supply either this parameter or the next one (tmp_infile).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with input sequence on the server. You need to supply either this parameter or the previous one (sequence).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input sequence format. Supported: IG (Intelligenetics), WC (wconsensus), raw, fasta. Default is fasta.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="length" type="xsd:int" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Oligomer length.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="seq_type" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Sequence type (values: dna, any).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="last" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Stop after a given number of sequences (for quick testing).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="mask" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Mask lower or uppercases by replacing the selected case by N (values: lower, upper).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="noov" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>No overlapping of oligos allowed if value = 1.
Disable the detection of overlapping matches for self-overlapping patterns (ex TATATA, GATAGA).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="str" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Oligonucleotide occurrences found on both stands are summed (2) or not (1). Default is 2.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="class_int" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Class interval. The width of the position classes, in number of bases (default: 20)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="origin" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Reference for computing positions. The value should be chosen according to the sequence type (start, for downstream sequences; end, for promoter sequences; center, for ChIP-seq peaks).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="offset" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Add an offset to site position (positive or negative integer). Allows to select an arbitrary position as origin.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="group_rc" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>group reverse complement pairs if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sort" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Sort oligomers according to the bias in distribution profile if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Fields to return. Several fields can be entered, comma separated (values: distrib, for occurences found in each position class; exp, for expected occurences in each class; graph, for a graph file per oligo profile; chi, for chi-square value; rank).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lth_chi" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Lower threshold on chi2.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lth_sig" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Lower threshold on significance.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lth_occ" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Lower threshold on the number of occurences.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="uth_rank" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Upper threshold on rank.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="max_graphs" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum number of graphs to export.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="pattern" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A selection of patterns you want the analysis to be restricted to. Newline separated. A score can be associated to each pattern with the option score_column</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_pattern_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with input patterns on the server. You need to supply either this parameter or the previous one (pattern).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="score_column" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>The column containing a score value for each pattern supplied with options pattern or tmp_pattern_infile. Only valid in combination with one of these options.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="min_pos" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Minimal position to take into account for the chi2 computation. This value must be a multiple of the class interval.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="max_pos" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximal position to take into account for the chi2 computation. This value must be a multiple of the class interval.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="no_check" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Do not check the applicability condition on the chi2 if set to 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="no_filter" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Do not discard oligos which do not fit the condition of applicability. Instead, mark them by including the chi2 value between curly brackets if set to 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="image_format" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Image format passed to XYgraph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="title" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Title for the index table and position profile plots.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="PatternAssemblyRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation pattern_assembly.</xsd:documentation>
        </xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="input" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input data</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input file on the server (workflow usage)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="verbosity" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Verbosity.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="score_col" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Score column. Column of the input file that contains the scores.
If not specified, patterns are incorporated according to their order in the input file.
However, if the input file has been generated with oligo-analysis or dyad-analysis with a verbosity >= 1,
pattern-assembly detects the occ_sig column in the file header and uses this column as score column.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="str" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Strands for the assembly: 1 for single-strand; 2 for two-strand assembly. Default is 2.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="maxfl" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum flanking segment size. Default is 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="subst" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum allowed substitutions. Default is 0.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="max_asmb_nb" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum number of assemblies. Default is 0 (no limit).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="max_asmb_size" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum assembly size, i.e. number of patterns per assembly. Default is 50.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="maxpat" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum number of allowed patterns. If the number of patterns exceeds this value, the program issues a fatal error.
Default is 0 (no limit). Not compatible with toppat option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="toppat" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum number of patterns to analyze.
If the number of patterns in the input exceeds this value, the assembly is restricted with the top patterns only.
Default: 100. Not compatible with maxpat option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="DnaPatternRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation dna_pattern.</xsd:documentation>
        </xsd:annotation>
       	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sequence" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input sequence. You need to supply either this parameter or the next one (tmp_infile).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with input sequence on the server. You need to supply either this parameter or the previous one (sequence).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input sequence format. Supported: IG (Intelligenetics), WC (wconsensus), raw, fasta. Default is fasta.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="subst" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of substitutions allowed.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="pattern" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Pattern to match. Use this option or the 'pattern_file' option</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="pattern_file" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>File with patterns to match. Use this option or the 'pattern' option</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_pattern_file" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>File located on the server with patterns to match (workflow usage).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="id" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Pattern identifier.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="origin" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Origin for the calculation of positions (0 for end of sequence).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="noov" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>No overlapping of oligos allowed if value = 1.
Disable the detection of overlapping matches for self-overlapping patterns (ex TATATA, GATAGA).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="score" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Score column. Column of the pattern file which contains the score</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="str" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Oligonucleotide occurrences found on both stands are summed (2) or not (1). Default is 2.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sort" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Sort oligomers according to overrepresentation if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="th" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Threshold on match count.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>List of fields to return. Multiple fields can be entered separated by commas.
Supported fields: colsum,counts,ct,limits,profiles,rank,rowsum,scores,sites,stats,table,total.
    sites: return match positions (default)
    limits: return start and end positions for each input sequence
    counts: return the count of matches per sequence
    rank: return the rank of the sequence (this is especially useful in combination with the option -sort)
    score: return a score per sequence, computed by summing the scores of the matching patterns
    ct: same as '-return counts', except that it returns the sum of matches in all the files of the sequence file list, instead of the count within each separate file
    table: return the count of pattern matches per sequence in the form of a table.  (one line per sequence, one column per pattern)
    colsum: (together with -return table) prints an extra column with the total occurrences per sequence
    rowsum: (together with -return table) prints an extra row with total occurrences per pattern
    total: (together with -return table) prints an extra column with the total occurrences per sequence and 
          an extra row with total occurrences per pattern.  (amounts to combine -colsum and -rowsum)
    stats: return matching statistics
    profiles: return matching profiles with sliding windows.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ConvertFeaturesRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation convert_features.</xsd:documentation>
        </xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="input" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input data</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input file on the server (workflow usage)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="from" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: dnapat,ft,gft,gff3,gff.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="to" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: dnapat,ft,gft,gff3,gff.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="coord" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Bedfile with absolute coordinate of the sequence fragment.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="FeatureMapRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation feature_map.</xsd:documentation>
        </xsd:annotation>
       	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="features" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>a list of features (ORFs, regulatory sites). Each feature is represented by a single line, which should	provide the following information:
Input file columns:
	1. map label (eg gene name)
	2. feature type
	3. feature identifier (ex: GATAbox, Abf1_site)
	4. strand (D for Direct, R for Reverse),
	5. feature start position
	6. feature end position
	7. (optional) description 
	8. (optional) score
The standard input format assumes that these topics are provided in this order, separated by tabs. Start and end positions can be positive or negative.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with input features on the server (workflow usage). You need to supply either this parameter or the previous one (features).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sequence" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input sequence(s).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_sequence_file" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Reference sequence file on the server (workflow usage)</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="sequence_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Format of reference sequence file on the server.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output image format. Supported: png,jpg,ps,gif (default = jpg)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="from" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Lower limit of the positions represented on the graph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="to" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Upper limit of the positions represented on the graph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="title" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Generic Title for the feature map.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="label" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Define the info to display for each feature. Valid keys are: id, strand, descr (feature descritption), pos (feature start and end positions).
Several keys can be entered separated by commas without space. ex: -label pos,id. (default = id).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="symbol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Associates a graphical symbol (i.e. rectangle, circle, buterfly, ...) to each feature. This is convenient to distinguish the features on black and white printings.
Mutually exclusive with the -dot option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="dot" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A color dot is associated to each feature. This allows to distinguish overlapping structures on a color screen. Mutually exclusive with the -symbol option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="mlen" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>map length (in pixels).Default is 600.Length refers to either height (for vertical maps) of width (for horizontal maps).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="mapthick" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Map thickness.Thickness refers to either width (for vertical maps) or height (horizintal maps). This parameter allows to change the thickness allocated to each map.
This is useful when labels are too large. Default is 150.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="mspacing" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Map spacing.The size of the border between maps (in pixel).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="origin" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>All coordinates are recalculated relative to this origin.This allows to display all coordinates with respect to the ORF start or transcription start site.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="legend" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Draws a legend on the graph, showing the symbol associated to each distinct feature.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="scalebar" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Draws a scale bar on the left of the graph.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="scalestep" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Step between annotations of the scale bar. If not specified, a reasonable step is calculated on basis of the scale bar range.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="scorethick" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Each feature is displayed with a thickness proportional to its score. Only positive scores are represented.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="maxscore" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>(only valid when -scorethick is active) Maximal allowed score value. Higher score values are clipped for the drawing.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="minscore" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>(only valid when -scorethick is active) Minimal allowed score value. Features with smaller score are not displayed.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="maxfthick" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Max feature thickness</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="minfthick" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Min feature thickness</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="htmap" type="xsd:int" minOccurs="0">
            <xsd:annotation>
	      <xsd:documentation>HTML map. An HTML document is automatically generated, which includes the feature map GIF file as an HTML map.
 In other words, this document displays a figure with sensitive areas. Each time the mouse is positioned above a feature, 
information about this particuliar feature is displayed at the bottom of the browser window.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="mono" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Monochrome palette (for printing on black/white printer).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="orientation" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Orientation of the map. Valid values are "horiz" for an horizontal map (default) and "vertic" for a vertical map.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="select" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation> Only display the features whose ID is in the provided id_list.
The id_list contains one or several IDs, separated by commas. IDs may be embraced in single quotes to allow multiple words within the IDs. 
Commas and single quotes are not allowed within an ID.
Example: -select 'gataag','gattag' only displays features identified by gataag or gattag.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="FootprintDiscoveryRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation footprint_discovery.</xsd:documentation>
        </xsd:annotation>
       	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="verbosity" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Level of detail for comments</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="genes" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A list of genes (one by line).
	      </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with a list of genes on the server. You need to supply either this parameter or the previous one (genes).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="all_genes" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Automatically analyze all the genes of a query genome, and store each result in a separate folder (the folder name is defined automatically).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="max_genes" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum number of genes to analyze.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="output_prefix" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Prefix for the output files. If the prefix is not specified, the program can guess a default prefix, but this is working only if there is a single query gene or query file.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="query" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A list of genes (referenced array).
	      </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sep_genes" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Search footprints for each query gene separately. The results arestored in a separate folder for each	gene. The folder name is defined automatically.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="organism" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Query organism, to which the query genes belong.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="taxon" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Reference taxon, in which orthologous genes have to be collected.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="index" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Generate an HTML index with links to the result files.
This option is used for the web interface, but can also be convenient to index results, especially when several genes or taxa are analyzed (options -genes, -all_genes, -all_taxa).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>Lower threshold on some parameters. Format: parameter value.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="uth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>Upper threshold on some parameters. Format: parameter value.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return fields for dyad-analysis. See dyad_analysis for a list</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="to_matrix" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Convert assembled patterns into position-specific scoring matrices (PSSM).
Caution ! This conversion can take time if the sequence set is large and if there are many assemblies.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="bg_model" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Allow the user to choose among alternative background model.
                                 - taxfreq
                                      Taxon-wide background model, computed by counting dyad frequencies in all the promoters of all the genes of the reference taxon.
                                 - monads
                                      Expected dyad frequencies are the product of monad frequencies observed in the input sequences.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="no_filter" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Accept all dyads, even if they are not found in the promoter of the query gene, in the query organism.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="infer_operons" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Infer operons in order to retrieve the promoters of the predicted operon leader genes rather than those located immediately upstream of the orthologs.
This method uses a threshold on the intergenic distance.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="dist_thr" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Specify here the intergenic distance threshold in base pairs.
Pair of adjacent genes with intergenic distance equal or less than this value are predicted to be within operon. (default : 55).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GetOrthologsRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation get_orthologs.</xsd:documentation>
        </xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="organism" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="taxon" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Reference taxon. Orthologs are returned for each supported organism belonging to the reference taxon.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="query" type="xsd:string" minOccurs="1" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>List of gene(s) for which you want to get orthologs.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Get orthologs for all the genes of the query organism if value = 1. This option is particularly convenient to extract phylogenetic profiles.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="nogrep" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Disable the pre-filtering with grep if value = 1.
This pre-filtering accelerates the selection of hits, but some grep versions do not support the -E option.
If this is the case on your operating system, you can still obtain the correct results by inactivating the grep filter.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output field(s).
By default, the output is a two-column file indicating the ID of the gene identified as similar to the query gene, and the name of the reference organism.
The option -return can be used to specify additional output fields.
Supported fields:
       - ref_id: ID of the reference (target) gene
       - ref_organism: Name of the reference (target) organism
       - query_id: ID of the query gene
       - query_organism: Name of the query organism
       - ident: Percent of identity (a number between 0 and 100)
       - ali_len: Alignment lengths (in residues)
       - mismat: Number of mismatches
       - gap_open: Number of gap openings
       - e_value: E-value (expected number of false positives)
       - bit_sc: Bit score
       - rank: Rank
       - s_rank: Source rank (rank of the hit for the query organism).
Several output fields can be entered separated by commas.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>Lower threshold for dyad-analysis. Format: list of 'parameter value'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="uth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>Upper threshold for dyad-analysis. Format: list of 'parameter value'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="InferOperonRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="organism" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="query" type="xsd:string" minOccurs="1" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>List of gene(s) for which you want to infer the operon.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with query genes on the server. You need to supply either this parameter or the previous one (query).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Infer operons for all the genes of the query organism if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="distance" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Distance threshold.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="min_gene_nb" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Min number of genes to report the operon.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>List of fields to return.
Supported fields: leader,trailer,operon,query,q_info,up_info,down_info
       - leader: Predicted operon leader.
       - trailer: Predicted operon trailer.
       - operon: Full composition of the operon. The names of member genes are separated by a semi-column ";".
       - q_info: Detailed info on the query gene(s).
       - up_info: Detailed info on the upstream gene.
       - down_info: Detailed info on the downstream gene.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GeneInfoRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="organism" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="query" type="xsd:string" minOccurs="1" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>List of gene(s) for which you want info on or list of keywords to search for (can be regular expressions).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="full" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Full match only (no substring matching) if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="noquery" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Do not print the query at the begining of each line if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="descr" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Match query against the description, too, not just against gene ID and name if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="feattype" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Feature type (CDS, mRNA, tRNA, rRNA, scRNA).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="all_genes" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Get info for all genes if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ClassFreqRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputFile" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Input file</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="classinterval" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>class interval. If not specified, takes the value (max - min)/20</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="col" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>column to which apply the program. This option can be used iteratively.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="min" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>numbers strictly smaller than this value are not taken into account</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="max" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>numbers strictly higher than this value are not taken into account</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="from" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Inferior limit for the classes to display. Values lower than this limit are however taken into account in the calculation of statistics (avg, variance, ...) 
and of class frequencies (In contrast with the -min option).
	      </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="to" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Superior limit for the classes to display. Values higher than this limit are however taken into account in the calculation of statistics (avg, variance, ...) 
and of class frequencies (In contrast with the -min option).
	      </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="XYGraphRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputFile" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>The input file should contain columns with numeric data. Each line contains info about one point of the graph.
By default, the first column is considered to contain X data, and the second column Y data. X and Y columns can be changed with -xcol and -ycol options.
Columns should be separated by tabs.
              </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Supported : png,pdf,jpg,eps,gif</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="title1" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>first graph title</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="title2" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>second graph title</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lines" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>points are jointed by lines</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="legend" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Use the content of the first line from input file as legend for Y data.
	      </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="header" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>First line of the data file contains a column header. If option -legend is active, this header is used as legend, else it is ignored.
	      </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="xleg1" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>first x legend</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="xleg2" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>second x legend</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="yleg1" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>first y legend</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="yleg2" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>second y legend</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="xmax" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>maximal value represented on X axis.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ymax" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>maximal value represented on Y axis.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="xmin" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>minimal value represented on X axis.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ymin" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>minimal value represented on Y axis.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ylog" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Y data are displayed on a logarithmic scale. If the next argument is a number, it provides the log base. Default log base is 10.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="xlog" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>X data are displayed on a logarithmic scale. If the next argument is a number, it provides the log base. Default log base is 10.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="xcol" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Column containing data for the X axis.
A zero value indicates that there is no column with X va lues. In this case, X values are ordinal.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ycol" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Column containing data for the Y axis.
Several columns can be specified by -ycol #,#,#. A range of columns can be specified by -ycol #-#. They have to be separated by commas without spaces.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RocStatsRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputfile" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>The input file</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Column of the input ile containing the score value (default 1).</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Column of the input file containing the status label (default 2).</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="status" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>This option allows to use different labels as synonyms for the pre-defined status: pos and neg.
It can be useful to rename these labels, for compatibility with other programs.
For example, it your input file contains annotations of "site" and "non-site", you can use it directly as input with the options.
-status site pos -status non-site neg indicates that the label "site" has to be understood as positive, and "non-site" as negative.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="total" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Total number of elements in the universe (neg + pos).
This option allows to manually specify the total number of elements, in case the input file would not contain the complete data set.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
       </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="TextToHtmlRequest">
       <xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputfile" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>The text input file that will be converted in html</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="chunk" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Chunk size (when there are many rows, the program splits the table into several HTML tables, to reduce the waiting time on the browser.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="no_sort" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>make the output HTML table not sortable.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="font" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Use fixed or variable fonts in html. Supported : variable,fixed</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
       </xsd:sequence>
      </xsd:complexType>
      
      <xsd:complexType name="ParsePsiXmlRequest">
       <xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputfile" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>The psi XML input file that will be converted in a tab file</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="channels" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A list of evidence channels to filter separated by a comma</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="interactor_type" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A list of interactor_type to filter (separated by comas) : protein, 'small molecule'</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="uth" type="xsd:float" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Upper threshold on the value</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lth" type="xsd:float" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Lower threshold on the value</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
       </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="SupportedOrganismsRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation supported_organisms.</xsd:documentation>
        </xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="return" type="xsd:string" minOccurs="0">
            <xsd:annotation>
	      <xsd:documentation>Return fields. Supported: ID,name,data,last_update,taxonomy,up_from,up_to,genome,seq_format,source.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: html_list, html_table, array, text, keys, names, sizes, full, tree, html_tree.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="taxon" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Root taxon.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="source" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Only returns organisms from a user-selected source. Example: supported-organisms -source ensembl</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="depth" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Traversal depth for the taxononmic tree. If several organisms are supported in a max-dept taxon, only one is reported.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="SupportedMotifDatabasesRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation supported_organisms.</xsd:documentation>
        </xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="return" type="xsd:string" minOccurs="0">
            <xsd:annotation>
	      <xsd:documentation>Return fields. Supported: name,format,file,descr,version,url.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ConvertSeqRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation convert_seq.</xsd:documentation>
        </xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
        <xsd:element name="sequence" type="xsd:string" minOccurs="0">
	 <xsd:annotation>
	  <xsd:documentation>Sequence to convert.</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
        <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	 <xsd:annotation>
	  <xsd:documentation>Name of the file with input sequence on the server. You need to supply either this parameter or the previous one (sequence).</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
	<xsd:element name="from" type="xsd:string" minOccurs="1">
	 <xsd:annotation>
	  <xsd:documentation>Format of input sequence (embl, fasta, filelist, gcg, genbank, ig, maf, multi, ncbi, raw, tab, wc, wconsensus).</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
	<xsd:element name="to" type="xsd:string" minOccurs="1">
	 <xsd:annotation>
	  <xsd:documentation>Format of output sequence (fasta, filelist, ft, ig, multi, raw, tab, wc, wconsensus).</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
       </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="CompareClassesRequest">
	<xsd:annotation>
	  <xsd:documentation>Parameters for the operation compare_classes.</xsd:documentation>
	</xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ref_classes" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>A tab-delimited text file containing the description of reference classes</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="query_classes" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>A tab-delimited text file containing the description of query classes</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="return_fields" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>List of fields to return separated by a comma. Supported: dotprod, entropy, freq, jac_sim, members, occ, proba, rank</xsd:documentation>
            </xsd:annotation>
          </xsd:element> 
          <xsd:element name="score_column" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Specify a column of the input file containing a score associated to each member</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="input_classes" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>This file will be used as both reference and query.This is equivalent to -q input_file -r input_file.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="upper_threshold_field" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Supported fields: E(QR), E_val, F(!Q!R), F(Q!R), F(Q), F(QR), F(R!Q), F(R), H(Q), H(Q,R), H(Q|R), H(R), H(R|Q), 
I(Q,R), IC, P(QR), P(Q|R), P(R|Q), P_val, Q, QR, QvR, R, U(Q|R), U(R|Q), dH(Q,R), dotprod, jac_sim, rank, sigE(QR), 
E_val, F(!Q!R), F(Q!R), F(Q), F(QR), F(R!Q), F(R), H(Q), H(Q,R), H(Q|R), H(R), H(R|Q), I(Q,R), IC, P(QR), P(Q|R), 
P(R|Q), P_val, Q, QR, QvR, R, U(Q|R), U(R|Q), dH(Q,R), dotprod, dp_bits, jac_sim, log2_dp, names, prodrts, sig, sqrt_dp.
Separate with semicolumn (":") as there are fields containing commas.</xsd:documentation>
            </xsd:annotation>
          </xsd:element> 
          <xsd:element name="upper_threshold_value" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Upper threshold value for a supported field. There must be as many thresholds values as thresholds fields in the same order as the list of threshold fields were given. </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="lower_threshold_field" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Supported fields: same fields as upper_threshold_field.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="lower_threshold_value" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Lower threshold value for a given field.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="population" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Population size. If not specified, the population size is estimated as the number of distinct elemenst in the whole set of reference classes.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="sort" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Sort on the basis of the specified key.</xsd:documentation>
            </xsd:annotation>
          </xsd:element> 
          <xsd:element name="distinct" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Prevent to compare each class with itself (when the reference and query files contain the same classes)</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="triangle" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>(only valid if query file and reference file are the same) Do not perform the reciprocal comparisons.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>  
	  <xsd:element name="matrix" type="xsd:string" minOccurs="0">
            <xsd:annotation>
            <xsd:documentation>Return a pairwise matrix, where each row corresponds to a reference class, each column to a query class, and each cell contains a comparison between the two classes. 
The next argument indicates which statistics has to be return in the matrix (default = sig) 
Supported: E(QR), E_val, F(!Q!R), F(Q!R), F(Q), F(QR), F(R!Q), F(R), H(Q), H(Q,R), H(Q|R), H(R), H(R|Q), I(Q,R), IC, P(QR), P(Q|R), P(R|Q),
P_val, Q, QR, QvR, R, U(Q|R), U(R|Q), dH(Q,R), dotprod, jac_sim, rank, sig</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="multi_correction" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Factor used for the multi-testing correction.
Supported values:
  nt  number of significance tests (default)
  nq  number of query classes
  nr  number of reference classes
  nc  number of comparisons (nc = nq * nr)</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ConvertClassesRequest">
	<xsd:annotation>
	  <xsd:documentation>Parameters for the operation convert-classes.</xsd:documentation>
	</xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Input format : supported tab, profiles, mcl</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Output format : supported tab, profiles, mcl</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="member_col" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Member column. Column containing the member names in the tab format (default 1).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="class_col" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Class column. Column containing the class names in the tab format  (default 2).</xsd:documentation>
            </xsd:annotation>
          </xsd:element> 
          <xsd:element name="score_col" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Score column. Column containing the score in the tab format : if not specified, scores are not defined..</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="min_score" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Minimal score value for member to class assignation.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="inputclasses" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Input classes in the format defined by the input_format tag</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="names" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Two tab-delimited columns specifying the labels of the members of the classification given in the classification file.
First column contains the identifier and second column the corresponding label.</xsd:documentation>
            </xsd:annotation>
          </xsd:element> 
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ContingencyTableRequest">
	<xsd:annotation>
	  <xsd:documentation>Parameters for the operation contingency_table.</xsd:documentation>
	</xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputfile" type="xsd:string" minOccurs="1">
            <xsd:annotation>
              <xsd:documentation>A tab delimited file</xsd:documentation>
            </xsd:annotation>
	  </xsd:element> 
	  <xsd:element name="col1" type="xsd:int" minOccurs="1">
            <xsd:annotation>
              <xsd:documentation>First column to use for the contingency table</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="col2" type="xsd:int" minOccurs="1">
            <xsd:annotation>
              <xsd:documentation>Second column to use for the contingency table</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="margin" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Calculate the marginal sums</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="null" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Value for the null character (default: 0).</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ContingencyStatsRequest">
	<xsd:annotation>
	  <xsd:documentation>Parameters for the operation contingency-stats.</xsd:documentation>
	</xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="inputfile" type="xsd:string" minOccurs="1">
            <xsd:annotation>
              <xsd:documentation>A contingency table : a N*M table used to compare the contents of two classifications. 
Rows represent the clusters of the first classification (considered as reference), and columns the clusters of the second classification (query).</xsd:documentation>
            </xsd:annotation>
          </xsd:element> 
          <xsd:element name="decimals" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Number of decimals to display for the computed statistics.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="return" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>List of fields to return.
    stats : table-wise statistics
    rowstats : row-wise statistics (one line per row of the contingency table)
    colstats : column-wise statistics (one line per column of the contingency table)
    tables : full tables for each statistics (counts, Sn, PPV, separation).
    margins : marginal statistics besides the tables (requires to return tables).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="rsizes" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Specify row group sizes in a separate file.
This option can be used in particular cases where the marginal sum of the contingency table does not correspond to the group sizes 
(for example if a classification supports the same elements assigned to multiple groups, or on the contrary if some elements can be unassigned).
The row size file must contain one row per row of the contingency table, and two columns. The first column indicated the name of the row 
(the same name as in the contingency table), and the second the size of the corresponding group.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="csizes" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Specify column group sizes in a separate file. Same description as for -rsizes tag.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="MatrixDistribRequest">
	<xsd:annotation>
	  <xsd:documentation>Parameters for the operation matrix_distrib</xsd:documentation>
	</xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="matrix_file" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>The matrix file content. Matrix format is specified with the option "matrix_format" (see below) Default format: tab.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_matrix_file" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>Name of the file containing matrix on the server. You need to supply either this parameter or the previous one (matrix_file).</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="matrix_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Supported fields: tab, cb, consensus, gibbs, meme, assembly.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element> 
	  <xsd:element name="matrix_pseudo" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Pseudo counts to apply on the matrix. Default: 1.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Background model file is a tab-delimited file containing the specification of oligonucleotide frequencies.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_pseudo" type="xsd:float" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Pseudo frequency for the background models. Value must be a real between 0 and 1. Default: 0.01.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="decimals" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Number of decimals for the matrix frequencies.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Background format.upported formats: all the input formats supported by convert-background-model.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="CompareMatricesRequest">
	<xsd:annotation>
	  <xsd:documentation>Parameters for the operation compare_matrices</xsd:documentation>
	</xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="matrix_1" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>The first input containing one or several matrices. Matrix format is specified with the option format1 or format (see below).</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="matrix_2" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>The second input containing one or several matrices. Matrix format is specified with the option format2 or format (see below).</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="matrix" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Single input containing one or several matrices. Each matrix of this file is compared to each other. Matrix format is specified with the option format (see below).</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_matrix1_infile" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>Name of the first file containing matrix/ces on the server. You need to supply either this parameter or matrix_1 (or matrix or tmp_matrix_infile).</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_matrix2_infile" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>Name of the second file containing matrix/ces on the server. You need to supply either this parameter or matrix_2 (or matrix or tmp_matrix_infile).</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_matrix_infile" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>Name of the single file containing matrix/ces on the server. You need to supply either this parameter or matrix (or use matrix_1 + matrix_2).</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="format1" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Martix format for the first input. Supported fields: tab, cb, consensus, gibbs, meme, assembly.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="format2" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Matrix format for the second input. Supported fields: tab, cb, consensus, gibbs, meme, assembly.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Matrix format for both inputs. Supported fields: tab, cb, consensus, gibbs, meme, assembly.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element> 
	  <xsd:element name="background_model" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Background model is tab-delimited and contains the specification of oligonucleotide frequencies.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_background_infile" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Background model file on the server. It is a tab-delimited file containing the specification of oligonucleotide frequencies.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Format for the background model file. Supported formats: all the input formats supported by convert-background-model.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="top1" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Only analyze the first X motifs of the first file. This options is convenient for quick testing before starting the full analysis.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="top2" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Only analyze the first X motifs of the second file. This options is convenient for quick testing before starting the full analysis.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="output_prefix" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Prefix for the output files. The output prefix is mandatory for some return fields (alignments, graphs, ...). This prefix will be appended with a series of suffixes for the different output types (see section OUTPUT FORMATS above for the detail).</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="mode" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>-format matches (default)
            Return matches between any matrix of file1 and any matrix of file2.

            This is the typical use of compare-matrices: comparing one or several query motifs (e.g. obtained from pattern discovery) with a collection of reference motifs (e.f. a database of experimentally characterized transcription factor binding motifs, such as JASPAR, TRANSFAC, RegulonDB, ...).

            For a given pair of matrices (one from file1 and one from file2), the program tests all possible offsets, and measures one or several matching scores (see section "(Dis)similarity metrics" above). The program only returns the sore of the best alignemnt between the two matrices. The "best" alignement is the combination of offset and strand (with the option -strand DR) that maximizes the default score (Ncor). Alternative scores can be used as optimality criteria with the option -sort.

        -format profiles
            Return a table with one row for each possible alignment offset between two matrices, and various columns indicating the matching parameters (offset, strand, aligned width,...), the matching scores, and the consensus of the aligned columns of the matrices.

            Matching profiles are convenient for drawing the similarity profiles, or for analyzing the correlations between various similarity metrics, but they are too verbosy for the typical use of compare-matrices (detect matches between a query matrix and a database of reference matrices). The formats "matches" and "table" are more convenient for basic use.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="distinct" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Skip comparison between a matrix and itself.

        This option is useful when the program is sused to compare all matrices of a given file to all matrices of the same file, to avoid comparing each matrix to itself.

        Beware: the criterion for considering two matrices identical is that they have the same identifier. If two matrices have exactly the same content (in terms of occurrences per position) but different identifiers, they will be compared.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="strand" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Perform matrix comparisons in direct (D) reverse complementary (R) or both orientations (DR, default option).

        When the R or DR options are activated, all matrices of the second matrix file are converted to the reverse complementary matrix.

        This option is useful to answer very particular questions, for example

        Comparing motifs in a strand-insensitive way (-strand DR)
            DNA-binding motifs are usually strand-insensitive. A motif may be detected in one given orientation by a motif-discovery algorithm, but annotated in the reverse complementary orientation in a motif database. For DNA binding motifs, we thus recomment the DR option.

            On the contrary, RNA-related signals (termination, poly-adenylation, miRNA) are strand-sensitive, and should be compared in a single orientation (-strand D).

        Detecting reverse complementary palindromic motifs
            An example of reverse complementary palindromic motif is tCAGswwsGTGa. When a motif is reverse complementary palindromic, the matrix is correlated to its own reverse complement.

            Remark about a frequent misconception of biological palindromes

            Reverse complementary palindroms are frequent in DNA signals (e.g. transcription factor binding sites, restriction sites, ...) because they correspond to a rotational symmetry in the 3D structure. Such symmetrical motifs are often characteristic of sites recognized by homodimeric complexes.

            By contrast, simple string-based palindromes (e.g. CAGTTGAC) do absolutely not correspond to any symmetry on the biochemical point of view, because the 3D structure of the corresponding double helix is not symmetrical. The apparent symmetry is an artifact of the string-based representation, but the corresponding molecule has neither rotational nor translational symmetry.

            DNA signals can either be symmetrical (reverse complementary palindromes, tandem repeats) or asymmetrical.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="matrix_id" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Obsolete option for returning matrix names, Replaced by -return matrix_name. Maintained for backward compatibility.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>List of fields to return (only valid for the formats "profiles" and "matches").

        Supported return fields:

        offset
            Offset (shift) between the two compared matrices.

        cor
            Pearsons coefficient of correlatiojn.

        Ncor
            Normalized correlation (default sorting criterion for the matching mode).

        cov
            Covariance.

        SSD
            Sum of squared distances.

        NSW
            Normalized Sandelin-Wasserman similarity.

        SW
            Sandelin-Wasserman similarity.

        dEucl
            Euclidian distance

        NdEucl
            Normalized Euclidian distance.

        NsEucl
            Normalized Euclidian similarity.

        dKL
            Kullback-Leibler distance

        matrix_number
            Number of the matrices in the input files

        matrix_id
            Identifiers of the matrices

        matrix_name
            Names of the matrices

        matrix_ac
            Accession number of the matrices (TRANSFAC format makes a distinction between IDs and accession numbers).

        width
            Width of the matrices and the alignment

        strand
            Direct (D) or Reverse complementary (R) comparison

        offset
            Offset between the positions of the first and second matrix
        pos
            Relative positions the aligned matrices (start, end, strand, width)

        consensus
            Aligned consensus. The residues of the consensus corresponding to aligned columns are displaye, non-aligned columns are replaced by dots.

        offset_rank
            During pairwise alignment, scores are computed for each offset and offsets are sorted according to the sorting criterion. The offset_rank indicates the rank of an offset in this sorted list. This is a "within-alignment" rank, which is useful in profile mode.

        match_rank
            In matching mode, ranks can be computed for all the selected metrics, and a mean rank is computed.

        alignments_pairwise
            Shifted matrices resulting from the pairwise alignments.

        alignments_1ton
            Shifted matrices resulting from the 1-to-N alignments.

        alignments
            Shifted matrices resulting from the alignments (pairwise and 1-to-N).

        all
            All supported output fields, including all metrics.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sort" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Field to sort the results. The sorting direction depends on the metric: ascending for dissimilarity metrics, decreasing for similarity metrics.

        Supported sort fields:

        offset, ascending (default sorting criterion for the profile mode)
        Ncor, decreasing (default sorting criterion for the matching mode)
        cor, decreasing
        cov, decreasing
        SSD, ascending
        SW, decreasing
        NSW, decreasing
        dEucl, ascending
        NdEucl, ascending
        NsEucl, decreasing
        dKL, ascending</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	<xsd:element name="lth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	  <xsd:annotation>
	    <xsd:documentation>Lower threshold on some parameter. Format=list of 'parameter value'.
Supported fields: rank, dEucl, cor, cov, ali_len, offset</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="uth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	  <xsd:annotation>
	    <xsd:documentation>Upper threshold on some parameter. Format=list of 'param value'.
Supported parameters: same as lth.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="MatrixScanRequest">
	<xsd:annotation>
	  <xsd:documentation>Parameters for the operation matrix_scan</xsd:documentation>
	</xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sequence" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Sequence(s) to scan - all the formats supported in RSAT can be used as input (default: fasta)</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	<xsd:element name="tmp_sequence_infile" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Name of the file with input sequence(s) on the server. You need to supply either this parameter or the previous one (sequence).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	  <xsd:element name="matrix" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Matrix/ces to scan with. The matrix format is specified with the option "matrix_format" (see below) Default format: tab.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	<xsd:element name="tmp_matrix_infile" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Name of the file with input matrix/ces on the server. You need to supply either this parameter or the previous one (matrix).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	  <xsd:element name="sequence_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Supported fields: fasta (default), IG (Intelligenetics), WC (wconsensus), raw.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="matrix_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Supported fields: tab, cb, consensus, gibbs, meme, assembly.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="quick" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Delegates scanning to the C program matrix-scan-quick (developed by Matthieu Defrance). Evaluate if the quick mode is compatible with the selected output parameters, otherwise, run in the slower mode. Incompatible with - CRER scanning - window background model.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="n_treatment" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Treatment of N characters. These characters are often used in DNA sequences to represent undefined or masked nucleotides.
        skip
            N-containing regions are skipped.
        score
            N-containing regions are scored. The probability of an N is 1 for both the background model and the matrix. The N residues
            will thus contribute neither positively nor negatively to the weight score of the N-containing fragment. This option can be
            useful to detect sites which are at the border of N-containing regions, or in cases there are isolated N in the sequences.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="consensus_name" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Use the motif (degenerate) consensus as matrix name.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="pseudo" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Pseudo-count for the matrix (default: 1).
The pseudo-count reflects the possibility that residues that were not (yet) observed in the model might however be valid for future observations.
The pseudo-count is used to compute the corrected residue frequencies..</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="equi_pseudo" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>If this option is called, the pseudo-weight is distributed in an equiprobable way between residues.
By default, the pseudo-weight is distributed proportionally to residue priors, except for the -window option where equipseudo is default.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="top_matrices" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Only scan with the top # matrices per matrix file.
This option is valid for some file formats containing multiple matrices where top matrices are generally more informative.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_model" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Background model is a tab-delimited specification of oligonucleotide frequencies.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_background_infile" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Background model file (tab-delimited specification of oligonucleotide frequencies) on the server.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="organism" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>To use a precalculated background model from RSAT, choose the organism corresponding to the background model.
Works with background and markov options.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>To use a precalculated background model from RSAT. Works with organism and markov options.
Type of sequences used as background model for estimating expected oligonucleotide frequencies. 
Supported: upstream, upstream-noorf, upstream-noorf-rm, intergenic</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_input" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Calculate background model from the input sequence set.
This option requires to specify the order of the background model with the option markov.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_window" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Size of the sliding window for the background model calculation.
This option requires to specify the order of the background model with the option markov (suitable for short order model only markov 0 or 1)</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="markov" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Order of the markov chain for the background model. This option is incompatible with the option background.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_pseudo" type="xsd:float" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Pseudo frequency for the background models. Value must be a real between 0 and 1.
If this option is not specified, the pseudo-frequency value depends on the background calculation.
For -bginput and -window, the pseudo frequency is automatically calculated with the length (L) of the sequence following this formula:
    square-root of L divided by L+squareroot of L
For -bgfile, default value is 0.01.
If the training sequence length (L) is known, the value can be set by -bg_pseudo option to square-root of L divided by L+squareroot of L.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return_fields" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>List of fields to return. Supported fields: sites, rank, limits, normw, bg_model, matrix, freq_matrix, weight_matrix, distrib .</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sort_distrib" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
              <xsd:documentation>Sort score distribution by decreasing value of significance, if value = 1.
By default, the score distributions are sorted by score (weight).</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	<xsd:element name="lth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	  <xsd:annotation>
	    <xsd:documentation>Lower threshold on some parameter. Format=list of 'parameter value'.
Supported fields: score, pval, eval, sig, normw, proba_M, proba_B, rank, crer_sites, crer_size, occ, occ_sum, inv_cum, 
exp_occ, occ_pval, occ_eval, occ_sig, occ_sig_rank</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="uth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	  <xsd:annotation>
	    <xsd:documentation>Upper threshold on some parameter. Format=list of 'param value'.
Supported parameters: same as lth.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	  <xsd:element name="str" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Scan 1 or 2 strands for DNA sequences.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="verbosity" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Level of verbosity (detail in the warning messages during execution)</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="origin" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
              <xsd:documentation>Define the origin for the calculation of positions.
-origin -0 defines the end of each sequence as the origin.
The matching positions are then negative values, providing the distance between the match and the end of the sequence.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="decimals" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
              <xsd:documentation>Number of decimals displayed for the weight score.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="crer_ids" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
              <xsd:documentation>Assign one separate feature ID per CRER. This option is convenient to distinguish separate CRERs.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ConvertMatrixRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation convert_matrix.</xsd:documentation>
        </xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="matrix" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Matrix (or assembly or features) you want to convert.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_format" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Format for the background model (prior) files. Supported: oligo-analysis, MotifSampler, meme, dyads.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_pseudo" type="xsd:float" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Pseudo frequency for the background models. Value must be a real between 0 and 1 (default: 0.01).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="from" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input matrix format. Supported: alignace, assembly, cb, clustal, consensus, feature, gibbs, infogibbs, meme, motifsampler, tab, transfac.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="to" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output matrix format. Supported: consensus, patser, tab, transfac.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Result type (matrix content). Supported: consensus, counts, frequencies, info, information, logo, margins, parameters, profile, sites, wdistrib, weights.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sort" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>desc | asc | alpha sort_key.
Sort matrices according to the specified attribute (sort_key). The sorting can be done on numerical values, either in descending (desc) or ascending (asc) order.
It can also be done in alphabetical order (alpha).
The key must be one of the numeric parameters of the matrices (e.g. information.content, E-value, ...).
This option is convenient, for example, to sort matrices from MotifSampler according to their information content:
        -sort desc MS.ic.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="top" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximal number of matrices to return. 
Some of the input formats can contain several matrices in a single file (e.g. consensus, meme, MotifSampler).
By default, all the matrices are parsed and exported. The option -top allows to restrict the number of matrices to be exported.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="pseudo" type="xsd:float" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>pseudo-weight used for the calculation of the weight matrix (default: 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="equi_pseudo" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>If value is 1, the pseudo-weight is distributed in an equiprobable way between residues.
By default, the pseudo-weight is distributed proportionally to residue priors.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="base" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Base for the logarithms used in the scores involving a log-likelihood (weight and information content). Default: exp(1) (natural logarithms).
A common alternative to natural logarithms is to use logarithms in base 2, in which case the information content is computed in bits..</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="decimals" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of decimals to print for real matrices (frequencies, weights, information) or to compute score distributions.
Warning: for the computation of score distributions, the computing time increases exponentially with the number of decimals.
We recommend to restrict the precision to 2 decimals for the weight, this is generally more than sufficient.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="perm" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of permuted matrices to return.
Matrix columns are permuted so that the total information content remains identical to the original matrix.
Note that the output format for permuted matrix is tab.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="max_profile" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximal width of the profile histogram (units = number of characters).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="rc" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Convert the matrix to its reverse complement if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RandomSequenceRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation random_seq.</xsd:documentation>
        </xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="sequence_length" type="xsd:int" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Length of sequence to generate.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="repetition" type="xsd:int" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Number of sequences to generate.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="format" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Format of sequence(s) to generate.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="line_width" type="xsd:int" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>A newline character will be inserted in the sequence every # bases, where # is the number provided. 
Default is 70. A value of 0 will prevent newline insertion.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="type" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Type of sequence(s) to generate (protein | DNA | other).</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="seed" type="xsd:int" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Seed for the random generator.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="alphabet" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Alphabet. Must be followed by residue frequencies expressed precisely this way:    a:t # c:g #</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="expfreq" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Expected frequencies of oligomers in sequence(s) to generate. Indicate the file that contains expected oligomer frequencies. 
When this option is used, the sequences are generated according to a Markov chain.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="tmp_expfreq_file" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Name of the file with expected frequencies on the server.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="bg_model" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Background model. Automatically load a pre-calibrated exected frequency file from the RSAT genome distribution. 
When this option is used, the options organism and oligo_length are also required, to indicate the organism and the oligonucleotide length, respectively.
This option is incompatible with the option expfreq.                 
Type of sequences used as background model for estimating expected oligonucleotide frequencies (supported models):
  - equi (equiprobable residue frequencies [default]), 
  - upstream (all upstream sequences, allowing overlap with upstream ORFs. Requires to speciy a model organism), 
  - upstream-noorf (all upstream sequences, preventing overlap with upstream ORFs. Requires to specify a model organism), and 
  - intergenic (intergenic frequencies. Whole set of intergenic regions, including upstream and downstream sequences. Requires to specify a model organism).</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="organism" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Name of the organism when using a background model.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="oligo_length" type="xsd:int" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Length of oligomer when using a background model.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
	 <xsd:element name="length_file" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Length file. Allows to generate random sequences with the same lengths as a set of reference sequences.
The length file contains two columns : sequence ID (ignored) and sequence length.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

            <xsd:complexType name="FetchSequencesRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation fetch_sequences.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="input" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>The input file should be in bed format.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="tmp_input_file" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Input file on the server.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="url" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Use as input a file available on a remote Web server (e.g. a bed file on your Galaxy account). This option is mutually exclusive with the previous two options.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="genome" type="xsd:string" minOccurs="1">
            <xsd:annotation>
              <xsd:documentation>Genome version (e.g. mm9, hg19).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="header_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Format for sequence headers (UCSC | galaxy).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="upstr_ext" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Extend each region by # base pairs on the upstream side (i.e. left side for + strands, right side for - strand)..</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="downstr_ext" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Extend each region by # base pairs on the downstream side (i.e. right for + strand, left for - strand)..</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="extend" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Extend each region by # base pairs on both upstream and downstream sides.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="reference" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Reference from which the sequences should be fetched.
		segment (default)
            Retrieve sequences from the start to the end positions of each
            feature (possibly extended with the options -upstr_ext, -downstr_ext or -extend).

		start | end | center
            Retrieve sequences relative to repsectively the start, the end or the central position of each feature.

            This option is generally combined with the options -upstr_ext, -downstr_ext or -extend, in order to retrieve sequences of a fixed width around the reference coordinate (e.g. 200 bp on each side of peak centers).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="top" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Only consider the # top features of the bed file as queries.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="chunck" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Send queries to UCSC by chunk of # features (default: chunk=10000).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <!-- NeA TOOLS REQUESTS -->
      <xsd:complexType name="ConvertGraphRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml, adj_matrix.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ecolors" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Compute an edge color for the GML output. The color intensity is proportional to the weight of the edge.
All weights in the column indicated by the -wcol argument must thus be real values.
Supported: green, blue, red, fire, grey.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: tab, gml, dot, adj_matrix.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label for the tab-delimited format (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="eccol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that containsthe color of the edge (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sccol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the color of the source node (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tccol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the color of the target node (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="pathcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify the column containing the paths</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="undirected" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>The graph is considered as being undirected (useful for the adjacency matrix input and output).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="distinct_path" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>The nodes belonging to different paths are duplicated with this option</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="layout" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify whether the disposition of each node has to be calculated using the $RSAT/bin/fr_layout program.
This option is only useful for GML output.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ewidth" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Calculate the edge width for the GML output. The width is proportional to the weight of the edge.
This value can only be computed for the GML output. All weights in the column indicated by the -wcol argument must thus be real values.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="target_xpos_col" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Column containing the X position of the target node</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="target_ypos_col" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Column containing the Y position of the target node</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="source_xpos_col" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Column containing the X position of the source node</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="source_ypos_col" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Column containing the Y position of the source node</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="AlterGraphRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml, adj_matrix.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: tab, gml, dot, adj_matrix.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label for the tab-delimited format (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="directed" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specifies whether the edges must be considered as directed, i.e., an     edge from node A to node B is different from an edge from B to A (by default, edges are not directed).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="duplicate" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specifies whether more than one edge may link two nodes. (by default, duplicated edges are not allowed).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="self" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Allows self loops (by default, self loops are not allowed)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="target" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Nodes that have to be removed in the graph (if existing). The node names must be separated by comas.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="add_nodes" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of edges to add. This value can either be a percentage value or a discrete number.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="rm_nodes" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of edges to remove. This value can either be a percentage value or a discrete number.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="add_edges" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of edges to add. This value can either be a percentage value or a discrete number.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="rm_edges" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of edges to remove. This value can either be a percentage value or a discrete number.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphCliquesRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml, adj_matrix.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="min_size" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Minimum size of the clique to return.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>      

      <xsd:complexType name="DisplayGraphRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml, adj_matrix.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: ps, png, jpeg.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ewidth" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Calculate the edge width for the GML output. The width is proportional to the weight of the edge. This value can only be
computed for the GML output. All weights in the column indicated by the -wcol argument must thus be real values.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label for the tab-delimited format (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="eccol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that containsthe color of the edge (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sccol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the color of the source node (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tccol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the color of the target node (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="layout" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Calculates the layout according to the Fruchterman and Reingold algorithm.
This option must be provided if the input graph is not GML.
	      </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="DrawHeatmapRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: png, jpeg.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="html" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Returns an HTML file that load the heatmap. The name of this file is the name of the output file on the server with the html extension </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputfile" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="row_names" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Use this option if the first column contain the row names.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="no_text" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Using this option, the values are not written in the cells of the heatmap</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="col_width" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Width of the columns (in pixel). If the row height is to small, the label of the heatmap will not be indicated. (Default : 50 px)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="row_height" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Height of the rows (in pixel). If the row height is to small, the label of the heatmap will not be indicated. (Default : 30 px)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="min" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Minimal value of the heatmap. By default, this value is the minimal value of the input file.
If the specified value is larger than the minimal value of the heatmap, then the minimal value of the heatmap will be used as minimal value.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="max" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximal value of the heatmap. By default, this value is the maximal value of the input file.
If the specified value is smaller than the maximal value of the heatmap, then the maximal value of the heatmap will be used as maximal value.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="gradient" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Color of the intensity gradient of the heatmap. Default is grey.
Supported : green, blue, red, fire, grey.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="CompareGraphsRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Qinformat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input format of query graph. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Rinformat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input format of reference graph. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: tab, gml, dot.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outweight" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Q (weights of the query graph), R (weights of the reference graph), sum (sum of the weights of the two graphs), 
mean (mean of the weights of the two graphs), mean.g (geometrical mean of the weights of the two graphs),
min (minimum weight), max (maximum weight), Q::R (weight of the two graphs) (default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Rinputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>The reference graph in the format specified by the informat tag.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Qinputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>The query graph in the format specified by the informat tag</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Qwcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the query input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Qscol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the query input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Qtcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the query input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Rwcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the reference input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Rscol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the reference input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Rtcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the reference input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>intersection, union, difference, R.and.Q, Q.and.R, Q.or.R, Q.not.R, R.not.Q, Q.and.R+Q, 
Q.and.R+R, R.and.Q+Q, R.and.Q+R, intersection+Q, intersection+R.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="directed" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Indicates whether the graphs must be considered as directed, i.e., an arc from node A to node B is different from an arc from B to A.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="self" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Indicates whether the graphs can admit self-loops, i.e., an arc from a node to itself. 
Note that the graphs do not specially need to contain actual self-loops, the question is whether 
it would or not be acceptable for the considered input graphs to contain self-loops.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphNodeDegreeRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>The degree of all nodes will be computed.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="nodefile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A file containing the nodes for which you want to know the degree.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      
      <xsd:complexType name="GraphTopologyRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>The statistics will be computed for all nodes.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>return type : degree, closeness, betweenness. More than one statistics can be returned by separating the fields with ','.
To return all implemented statistics, you can use all.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="nodefile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A file containing the nodes for which you want to know the degree and other statistics.</xsd:documentation>
	    </xsd:annotation>
          </xsd:element>
	  <xsd:element name="directed" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specifies whether the graph is directed or not (i.e. edge A-B corresponds to edge B-A).
In this case, the betweenness and the closeness calculation will be rather different.
By default the graph is not directed.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphClusterMembershipRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="clusters" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>clustering as a tab-delimited file.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="stat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Determines how the node membership will be calculated (edge, weight, relw).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="decimals" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of decimals to print for the membership. Note that by selecting this option, the entries of the membership-vectors (rows) won't sum up to 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RandomGraphRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: tab, gml, dot.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="random_type" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Randomization type:
- scratch (de novo graph) : don't forget to specify the number of nodes and of edges,
- ER (Erdos-Renyii randomization) : corresponds to the randomization of a input graph, keeping the nodes and the number of edges but changing its characteristics,
- node_degree : each node will keep the same degree that in the input graph (edge randomization),
- node_degree_distrib : the global distribution of node degree will remain the same as in the input graph.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="edges" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of requested edges (for scratch randomization type).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="degree" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximal degree of the nodes in the ER random graph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="nodes" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of requested nodes (for scratch randomization type).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="self" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Allows self loops (by default, self loops are not allowed)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="mean" type="xsd:float" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Mean value on the weight of the arcs.
This argument can only be used with the scratch and ER randomization type and must be combined with the -sd option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sd" type="xsd:float" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Standard deviation value of the weight of the arcs.
This argument can only be used with the scratch and ER randomization type and must be combined with the -mean option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="directed" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Indicates whether the graphs must be considered as directed, i.e., an arc from node A to node B is different from an arc from B to A.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="no_single" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Prevent the ER / scratch graph from containing nodes with no neighbour.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="duplicate" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specifies whether more than one edge may link two nodes (by default, duplicated edges are not allowed).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="col_conservation" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Only compatible with ER randomization of a graph. Source and target nodes stay source and target nodes in the randomized graph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="normal" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>This option can only be used with ER randomization type and if the input graph is weighted. 
Using this option will generate randomly the weight of the output random graph according to a normal distribution of weights. 
The mean and standard deviation can then be chosen (-mean and -sd option) or will be calculated according to the weights the input graph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="MCLRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the tab delimited format first column : source node, second column : target node, third column : edge weight</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inflation" type="xsd:float" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Sets the main inflation value. This value is the main handle for affecting cluster granularity. It is usually chosen somewhere in the range [1.2-5.0].
-I 5.0 will tend to result in fine-grained clusterings, and -I 1.2 will tend to result in very coarse grained clusterings.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>      

      <xsd:complexType name="RNSCRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format required by RNSC : an adjacency list in which each edge appears only once.
The vertices are labelled with the integers 0, 1, ..., n-1. The list of neighbours for vertex v appears as v n_1 n_2 ... n_x -1.
The input network in the correct format can be produced by the convert-graph program.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="max_clust" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Allow no more than "num" clusters.  "num" must be between 2 and n, where n is the number of vertices in the graph.
If this option is not specified or an invalid value is given, n clusters are used.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tabulength" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Set the tabu length to "num". Default value is 1. Note that when the tabulist option is used, vertices can appear 
on the tabu list more than once and moving them is only forbidden when they are on the tabu list more than TabuTol times, where TabuTol is the tabu list tolerance.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tabulist" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Set the tabu list tolerance to "num". Default value is 1.
The tabu list tolerance is the number of times a vertex must appear on the tabu list before moving it is forbidden.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="naive_stop" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Set the naive stopping tolerance to "num". Default value is 5. This is the number of steps that the naive scheme will continue without improving the best cost.
If you run the scaled scheme, using a higher naive stopping tolerance isn't likely to improve your results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scale_stop" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Set the scaled stopping tolerance to "num". Default value is 5. This is the number of steps that the scaled scheme will continue without improving the best cost.
Setting the tolerance to 0 will cause the algorithm to skip the scaled scheme.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="exp_nb" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Run "num" experiments. The best final clustering over all experiments will be written to file. Default is 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="div_freq" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Set the diversification frequency to "num". Without this option, no diversification will be performed.
If the shf_div_len flag is also used, then "num" is the shuffling diversification frequency.
If the -d flag is not used, then "num" is the destructive diversification frequency.
It is recommended that the shf_div_len flag is used, because destructive diversification isn't much help.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="shf_div_len" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Set the shuffling diversification length to "num". That means that the last "num" moves in the diversification period will be diversification moves.
Don't set this to be higher than the diversification frequency.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphNeighboursRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input graph. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="direction" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Direction of the neighbours (default all). Supported: in, out, all. This option cannot be used with the stat output and when specifying the number of steps</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>The neighbours of all nodes will be searched.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="stats" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Only valid when the number of step is equal to 1. The output file is presented differently, with one line for each seed node.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="self" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Include each node in its neighborhood, with a distance of 0, even if there is no self-loop at this node. 
This allows to extract the node together with its neighborhood, rather than the neighborhood only (default). This option cannot be used with the stats option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="seedfile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A list of nodes for which you want to know the neighbours.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="steps" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximal number of steps between a seed node and its neighbours. Default: 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphGetClustersRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Return format. Supported: table, cluster, graph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: tab, gml, dot.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="clusters" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Specification of the clusters to which belong the nodes.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="distinct" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>As some nodes may belong to more than one group, using this option will duplicate the nodes belonging to more than one group.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="induced" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Using this option, only the first column of the cluster file will be taken into account. 
The output graph will thus consist in the graph induced by all nodes of the first column.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <!-- GENERAL UTILITY TOOLS REQUESTS -->
      <xsd:complexType name="MonitorRequest">
	<xsd:sequence>
	  <xsd:element name="ticket" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Ticket of a job submitted with its output_choice set to 'ticket'.                                                                                                                                                                                                          </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GetResultRequest">
	<xsd:sequence>
	  <xsd:element name="ticket" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Ticket of a job submitted with its output_choice set to 'ticket'.                                                                                                                                                                                                           </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <!-- RSA TOOLS RESPONSES -->
      <xsd:complexType name="RetrieveSequenceResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RetrieveSequenceMultigenomeResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RetrieveEnsemblSequenceResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="PurgeSequenceResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="OligoAnalysisResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="OligoDiffResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="PeakMotifsResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="DyadAnalysisResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="PositionAnalysisResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="PatternAssemblyResponse">
        <xsd:sequence>
          <xsd:element name="server" type="xsd:string">
            <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="command" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="client" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The results.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="DnaPatternResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ConvertFeaturesResponse">
	<xsd:sequence>
          <xsd:element name="server" type="xsd:string">
            <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="command" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="client" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The results.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="FeatureMapResponse">
        <xsd:sequence>
          <xsd:element name="server" type="xsd:string">
            <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="command" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="client" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The results.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="FootprintDiscoveryResponse">
        <xsd:sequence>
          <xsd:element name="server" type="xsd:string">
            <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="command" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="client" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The results.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GetOrthologsResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="InferOperonResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GeneInfoResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="SupportedOrganismsResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="SupportedMotifDatabasesResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="TextToHtmlResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ParsePsiXmlResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RocStatsResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="XYGraphResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ClassFreqResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ConvertSeqResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="CompareClassesResponse">
   	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ConvertClassesResponse">
   	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ContingencyStatsResponse">
   	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ContingencyTableResponse">
   	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="CompareMatricesResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="MatrixScanResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ConvertMatrixResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      
       <xsd:complexType name="MatrixDistribResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RandomSequenceResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="FetchSequencesResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <!-- NeA TOOLS RESPONSES -->
      <xsd:complexType name="ConvertGraphResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      <xsd:complexType name="AlterGraphResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphCliquesResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="DisplayGraphResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="DrawHeatmapResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphNodeDegreeResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphTopologyResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphClusterMembershipResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="CompareGraphsResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphNeighboursResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="MCLResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RNSCResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RandomGraphResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphGetClustersResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                             </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <!-- GENERAL UTILITY TOOLS RESPONSES -->
      <xsd:complexType name="MonitorResponse">
	<xsd:sequence>
	  <xsd:element name="status" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Return status ('Running' or 'Done') of a job submitted with its output_choice set to 'ticket'.                                                                                                                                                                                             </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GetResultResponse">
	<xsd:sequence>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Return result of job submitted with its output_choice set to 'ticket'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                             </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <!-- RSA TOOLS MAIN ELEMENTS -->
      <xsd:element name="retrieve_seq">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:RetrieveSequenceRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="retrieve_seqResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:RetrieveSequenceResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="retrieve_seq_multigenome">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:RetrieveSequenceMultigenomeRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="retrieve_seq_multigenomeResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:RetrieveSequenceMultigenomeResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="retrieve_ensembl_seq">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:RetrieveEnsemblSequenceRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="retrieve_ensembl_seqResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:RetrieveEnsemblSequenceResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="purge_seq">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:PurgeSequenceRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="purge_seqResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:PurgeSequenceResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="oligo_analysis">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:OligoAnalysisRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="oligo_analysisResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:OligoAnalysisResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="oligo_diff">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:OligoDiffRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="oligo_diffResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:OligoDiffResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="peak_motifs">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:PeakMotifsRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="peak_motifsResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:PeakMotifsResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="dyad_analysis">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:DyadAnalysisRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="dyad_analysisResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:DyadAnalysisResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="position_analysis">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:PositionAnalysisRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="position_analysisResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:PositionAnalysisResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="pattern_assembly">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="request" type="tns:PatternAssemblyRequest" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="pattern_assemblyResponse">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="response" type="tns:PatternAssemblyResponse" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="dna_pattern">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:DnaPatternRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="dna_patternResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:DnaPatternResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_features">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="request" type="tns:ConvertFeaturesRequest" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_featuresResponse">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="response" type="tns:ConvertFeaturesResponse" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="feature_map">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="request" type="tns:FeatureMapRequest" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="feature_mapResponse">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="response" type="tns:FeatureMapResponse" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="footprint_discovery">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="request" type="tns:FootprintDiscoveryRequest" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="footprint_discoveryResponse">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="response" type="tns:FootprintDiscoveryResponse" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="get_orthologs">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GetOrthologsRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="get_orthologsResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GetOrthologsResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="infer_operon">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:InferOperonRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="infer_operonResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:InferOperonResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="gene_info">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GeneInfoRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="gene_infoResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GeneInfoResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="supported_organisms">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:SupportedOrganismsRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="supported_organismsResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:SupportedOrganismsResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="supported_motif_databases">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:SupportedMotifDatabasesRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="supported_motif_databasesResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:SupportedMotifDatabasesResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="text_to_html">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:TextToHtmlRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="text_to_htmlResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:TextToHtmlResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="parse_psi_xml">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ParsePsiXmlRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="parse_psi_xmlResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ParsePsiXmlResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="roc_stats">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:RocStatsRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="roc_statsResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:RocStatsResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="class_freq">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ClassFreqRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="class_freqResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ClassFreqResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="xy_graph">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:XYGraphRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="xy_graphResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:XYGraphResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_seq">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ConvertSeqRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_seqResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ConvertSeqResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="compare_classes">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:CompareClassesRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="compare_classesResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:CompareClassesResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_classes">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ConvertClassesRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_classesResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ConvertClassesResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="contingency_stats">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ContingencyStatsRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="contingency_statsResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ContingencyStatsResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="contingency_table">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ContingencyTableRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="contingency_tableResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ContingencyTableResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="compare_matrices">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:CompareMatricesRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="compare_matricesResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:CompareMatricesResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="matrix_scan">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:MatrixScanRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="matrix_scanResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:MatrixScanResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_matrix">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ConvertMatrixRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_matrixResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ConvertMatrixResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="matrix_distrib">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:MatrixDistribRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="matrix_distribResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:MatrixDistribResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="random_seq">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:RandomSequenceRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="random_seqResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:RandomSequenceResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="fetch_sequences">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:FetchSequencesRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="fetch_sequencesResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:FetchSequencesResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <!-- NeA TOOLS MAIN ELEMENTS -->
      <xsd:element name="convert_graph">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ConvertGraphRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_graphResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ConvertGraphResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="alter_graph">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:AlterGraphRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="alter_graphResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:AlterGraphResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_cliques">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GraphCliquesRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_cliquesResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GraphCliquesResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="display_graph">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:DisplayGraphRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="display_graphResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:DisplayGraphResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="draw_heatmap">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:DrawHeatmapRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="draw_heatmapResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:DrawHeatmapResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="compare_graphs">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:CompareGraphsRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="compare_graphsResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:CompareGraphsResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_node_degree">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GraphNodeDegreeRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_node_degreeResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GraphNodeDegreeResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_topology">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GraphTopologyRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_topologyResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GraphTopologyResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_cluster_membership">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GraphClusterMembershipRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_cluster_membershipResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GraphClusterMembershipResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_neighbours">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GraphNeighboursRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_neighboursResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GraphNeighboursResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="mcl">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:MCLRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="mclResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:MCLResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="rnsc">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:RNSCRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="r_n_s_cResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:RNSCResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="random_graph">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:RandomGraphRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="random_graphResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:RandomGraphResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_get_clusters">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GraphGetClustersRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_get_clustersResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GraphGetClustersResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <!-- GENERAL UTILITY TOOLS MAIN ELEMENTS -->
      <xsd:element name="monitor">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:MonitorRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="monitorResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:MonitorResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="get_result">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GetResultRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="get_resultResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GetResultResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

    </xsd:schema>
  </types>

  <!-- RSA TOOLS MESSAGES -->
  <message name="retrieve_seqRequest">
    <part name="parameters" element="tns:retrieve_seq"/>
  </message>

  <message name="retrieve_seqResponse">
    <part name="output" element="tns:retrieve_seqResponse"/>
  </message>

  <message name="retrieve_seq_multigenomeRequest">
    <part name="parameters" element="tns:retrieve_seq_multigenome"/>
  </message>

  <message name="retrieve_seq_multigenomeResponse">
    <part name="output" element="tns:retrieve_seq_multigenomeResponse"/>
  </message>

  <message name="retrieve_ensembl_seqRequest">
    <part name="parameters" element="tns:retrieve_ensembl_seq"/>
  </message>

  <message name="retrieve_ensembl_seqResponse">
    <part name="output" element="tns:retrieve_ensembl_seqResponse"/>
  </message>

  <message name="purge_seqRequest">
    <part name="parameters" element="tns:purge_seq"/>
  </message>

  <message name="purge_seqResponse">
    <part name="output" element="tns:purge_seqResponse"/>
  </message>

  <message name="oligo_analysisRequest">
    <part name="parameters" element="tns:oligo_analysis"/>
  </message>

  <message name="oligo_analysisResponse">
    <part name="output" element="tns:oligo_analysisResponse"/>
  </message>

  <message name="oligo_diffRequest">
    <part name="parameters" element="tns:oligo_diff"/>
  </message>

  <message name="oligo_diffResponse">
    <part name="output" element="tns:oligo_diffResponse"/>
  </message>

  <message name="peak_motifsRequest">
    <part name="parameters" element="tns:peak_motifs"/>
  </message>

  <message name="peak_motifsResponse">
    <part name="output" element="tns:peak_motifsResponse"/>
  </message>

  <message name="dyad_analysisRequest">
    <part name="parameters" element="tns:dyad_analysis"/>
  </message>

  <message name="dyad_analysisResponse">
    <part name="output" element="tns:dyad_analysisResponse"/>
  </message>

  <message name="position_analysisRequest">
    <part name="parameters" element="tns:position_analysis"/>
  </message>

  <message name="position_analysisResponse">
    <part name="output" element="tns:position_analysisResponse"/>
  </message>

  <message name="pattern_assemblyRequest">
    <part name="parameters" element="tns:pattern_assembly"/>
  </message>

  <message name="pattern_assemblyResponse">
    <part name="output" element="tns:pattern_assemblyResponse"/>
  </message>

  <message name="dna_patternRequest">
    <part name="parameters" element="tns:dna_pattern"/>
  </message>

  <message name="dna_patternResponse">
    <part name="output" element="tns:dna_patternResponse"/>
  </message>

  <message name="convert_featuresRequest">
    <part name="parameters" element="tns:convert_features"/>
  </message>

  <message name="convert_featuresResponse">
    <part name="output" element="tns:convert_featuresResponse"/>
  </message>

  <message name="feature_mapRequest">
    <part name="parameters" element="tns:feature_map"/>
  </message>

  <message name="feature_mapResponse">
    <part name="output" element="tns:feature_mapResponse"/>
  </message>

  <message name="footprint_discoveryRequest">
    <part name="parameters" element="tns:footprint_discovery"/>
  </message>

  <message name="footprint_discoveryResponse">
    <part name="output" element="tns:footprint_discoveryResponse"/>
  </message>

  <message name="get_orthologsRequest">
    <part name="parameters" element="tns:get_orthologs"/>
  </message>

  <message name="get_orthologsResponse">
    <part name="output" element="tns:get_orthologsResponse"/>
  </message>

  <message name="infer_operonRequest">
    <part name="parameters" element="tns:infer_operon"/>
  </message>

  <message name="infer_operonResponse">
    <part name="output" element="tns:infer_operonResponse"/>
  </message>

  <message name="gene_infoRequest">
    <part name="parameters" element="tns:gene_info"/>
  </message>

  <message name="gene_infoResponse">
    <part name="output" element="tns:gene_infoResponse"/>
  </message>

  <message name="supported_organismsRequest">
    <part name="parameters" element="tns:supported_organisms"/>
  </message>

  <message name="supported_organismsResponse">
    <part name="output" element="tns:supported_organismsResponse"/>
  </message>

  <message name="supported_motif_databasesRequest">
    <part name="parameters" element="tns:supported_motif_databases"/>
  </message>

  <message name="supported_motif_databasesResponse">
    <part name="output" element="tns:supported_motif_databasesResponse"/>
  </message>
  
  <message name="text_to_htmlRequest">
    <part name="parameters" element="tns:text_to_html"/>
  </message>

  <message name="text_to_htmlResponse">
    <part name="output" element="tns:text_to_htmlResponse"/>
  </message>

  <message name="parse_psi_xmlRequest">
    <part name="parameters" element="tns:parse_psi_xml"/>
  </message>

  <message name="parse_psi_xmlResponse">
    <part name="output" element="tns:parse_psi_xmlResponse"/>
  </message>

  <message name="roc_statsRequest">
    <part name="parameters" element="tns:roc_stats"/>
  </message>

  <message name="roc_statsResponse">
    <part name="output" element="tns:roc_statsResponse"/>
  </message>
  
  <message name="class_freqRequest">
    <part name="parameters" element="tns:class_freq"/>
  </message>
  
  <message name="class_freqResponse">
    <part name="output" element="tns:class_freqResponse"/>
  </message>

  <message name="xy_graphRequest">
    <part name="parameters" element="tns:xy_graph"/>
  </message>

  <message name="xy_graphResponse">
    <part name="output" element="tns:xy_graphResponse"/>
  </message>

  <message name="convert_seqRequest">
    <part name="parameters" element="tns:convert_seq"/>
  </message>

  <message name="convert_seqResponse">
    <part name="output" element="tns:convert_seqResponse"/>
  </message>

  <message name="compare_classesRequest">
    <part name="parameters" element="tns:compare_classes"/>
  </message>

  <message name="compare_classesResponse">
    <part name="output" element="tns:compare_classesResponse"/>
  </message>

  <message name="convert_classesRequest">
    <part name="parameters" element="tns:convert_classes"/>
  </message>

  <message name="convert_classesResponse">
    <part name="output" element="tns:convert_classesResponse"/>
  </message>

  <message name="contingency_statsRequest">
    <part name="parameters" element="tns:contingency_stats"/>
  </message>

  <message name="contingency_statsResponse">
    <part name="output" element="tns:contingency_statsResponse"/>
  </message>

  <message name="contingency_tableRequest">
    <part name="parameters" element="tns:contingency_table"/>
  </message>

  <message name="contingency_tableResponse">
    <part name="output" element="tns:contingency_tableResponse"/>
  </message>

  <message name="matrix_scanRequest">
    <part name="parameters" element="tns:matrix_scan"></part>
  </message>

  <message name="matrix_scanResponse">
    <part name="output" element="tns:matrix_scanResponse"></part>
  </message>

  <message name="convert_matrixRequest">
    <part name="parameters" element="tns:convert_matrix"></part>
  </message>

  <message name="convert_matrixResponse">
    <part name="output" element="tns:convert_matrixResponse"></part>
  </message>

  <message name="compare_matricesRequest">
    <part name="parameters" element="tns:compare_matrices"></part>
  </message>

  <message name="compare_matricesResponse">
    <part name="output" element="tns:compare_matricesResponse"></part>
  </message>

  <message name="matrix_distribRequest">
    <part name="parameters" element="tns:matrix_distrib"></part>
  </message>

  <message name="matrix_distribResponse">
    <part name="output" element="tns:matrix_distribResponse"></part>
  </message>

  <message name="random_seqRequest">
    <part name="parameters" element="tns:random_seq"/>
  </message>

  <message name="random_seqResponse">
    <part name="output" element="tns:random_seqResponse"/>
  </message>

  <message name="fetch_sequencesRequest">
    <part name="parameters" element="tns:fetch_sequences"/>
  </message>

  <message name="fetch_sequencesResponse">
    <part name="output" element="tns:fetch_sequencesResponse"/>
  </message>

  <!-- NeA TOOLS MESSAGES -->
  <message name="convert_graphRequest">
    <part name="parameters" element="tns:convert_graph"/>
  </message>

  <message name="convert_graphResponse">
    <part name="output" element="tns:convert_graphResponse"/>
  </message>

  <message name="alter_graphRequest">
    <part name="parameters" element="tns:alter_graph"/>
  </message>

  <message name="alter_graphResponse">
    <part name="output" element="tns:alter_graphResponse"/>
  </message>

  <message name="graph_cliquesRequest">
    <part name="parameters" element="tns:graph_cliques"/>
  </message>

  <message name="graph_cliquesResponse">
    <part name="output" element="tns:graph_cliquesResponse"/>
  </message>

  <message name="display_graphRequest">
	  <part name="parameters" element="tns:display_graph"/>
  </message>

  <message name="display_graphResponse">
	  <part name="output" element="tns:display_graphResponse"/>
  </message>

  <message name="draw_heatmapRequest">
	  <part name="parameters" element="tns:draw_heatmap"/>
  </message>

  <message name="draw_heatmapResponse">
	  <part name="output" element="tns:draw_heatmapResponse"/>
  </message>

  <message name="compare_graphsRequest">
    <part name="parameters" element="tns:compare_graphs"/>
  </message>

  <message name="compare_graphsResponse">
    <part name="output" element="tns:compare_graphsResponse"/>
  </message>

  <message name="graph_node_degreeRequest">
    <part name="parameters" element="tns:graph_node_degree"/>
  </message>

  <message name="graph_node_degreeResponse">
    <part name="output" element="tns:graph_node_degreeResponse"/>
  </message>

  <message name="graph_topologyRequest">
    <part name="parameters" element="tns:graph_topology"/>
  </message>

  <message name="graph_topologyResponse">
    <part name="output" element="tns:graph_topologyResponse"/>
  </message>

  <message name="graph_cluster_membershipRequest">
    <part name="parameters" element="tns:graph_cluster_membership"/>
  </message>

  <message name="graph_cluster_membershipResponse">
    <part name="output" element="tns:graph_cluster_membershipResponse"/>
  </message>

  <message name="random_graphRequest">
    <part name="parameters" element="tns:random_graph"/>
  </message>

  <message name="random_graphResponse">
    <part name="output" element="tns:random_graphResponse"/>
  </message>

  <message name="graph_get_clustersRequest">
    <part name="parameters" element="tns:graph_get_clusters"/>
  </message>

  <message name="graph_get_clustersResponse">
    <part name="output" element="tns:graph_get_clustersResponse"/>
  </message>

  <message name="graph_neighboursRequest">
    <part name="parameters" element="tns:graph_neighbours"/>
  </message>

  <message name="graph_neighboursResponse">
    <part name="output" element="tns:graph_neighboursResponse"/>
  </message>

  <message name="mclRequest">
    <part name="parameters" element="tns:mcl"/>
  </message>

  <message name="mclResponse">
    <part name="output" element="tns:mclResponse"/>
  </message>

  <message name="r_n_s_cRequest">
    <part name="parameters" element="tns:rnsc"/>
  </message>

  <message name="r_n_s_cResponse">
    <part name="output" element="tns:r_n_s_cResponse"/>
  </message>

  <!-- GENERAL UTILITY TOOLS MESSAGES -->
  <message name="monitorRequest">
    <part name="parameters" element="tns:monitor"/>
  </message>

  <message name="monitorResponse">
    <part name="output" element="tns:monitorResponse"/>
  </message>

  <message name="get_resultRequest">
    <part name="parameters" element="tns:get_result"/>
  </message>

  <message name="get_resultResponse">
    <part name="output" element="tns:get_resultResponse"/>
  </message>

  <portType name="RSATWSPortType">
    <!-- RSA TOOLS PORTTYPES -->
    <operation name="retrieve_seq">
      <documentation>Returns upstream, downstream or coding DNA sequences for list of query genes.</documentation>
      <input name="RetrieveSequenceRequest" message="tns:retrieve_seqRequest"/>
      <output name="RetrieveSequenceResponse" message="tns:retrieve_seqResponse"/>         
    </operation>
    <operation name="retrieve_seq_multigenome">
      <documentation>Returns upstream, downstream or coding DNA sequencesfor list of query genes and organisms.</documentation>
      <input name="RetrieveSequenceMultigenomeRequest" message="tns:retrieve_seq_multigenomeRequest"/>
      <output name="RetrieveSequenceMultigenomeResponse" message="tns:retrieve_seq_multigenomeResponse"/>         
    </operation>
    <operation name="retrieve_ensembl_seq">
      <documentation>Returns upstream, downstream or coding DNA sequences for list of query genes (in EnsEMBL database).</documentation>
      <input name="RetrieveEnsemblSequenceRequest" message="tns:retrieve_ensembl_seqRequest"/>
      <output name="RetrieveEnsemblSequenceResponse" message="tns:retrieve_ensembl_seqResponse"/>         
    </operation>
    <operation name="purge_seq">
      <documentation>Mask repeated fragments of an input sequence.</documentation>
      <input name="PurgeSequenceRequest" message="tns:purge_seqRequest"/>
      <output name="PurgeSequenceResponse" message="tns:purge_seqResponse"/>
    </operation>
    <operation name="oligo_analysis">
      <documentation>Analysis of the statistical significance of all the oligomers of a given size in a sequence. Commonly used to detect over-represented oligonucleotides in a set of promoter sequences.</documentation>
      <input name="OligoAnalysisRequest" message="tns:oligo_analysisRequest"/>
      <output name="OligoAnalysisResponse" message="tns:oligo_analysisResponse"/>
    </operation>
    <operation name="oligo_diff">
      <documentation>Compare oligonucleotide occurrences between two input sequence files (test and control), and return oligos that are significantly enriched in one of the files respective to the other one.</documentation>
      <input name="OligoDiffRequest" message="tns:oligo_diffRequest"/>
      <output name="OligoDiffResponse" message="tns:oligo_diffResponse"/>
    </operation>
    <operation name="peak_motifs">
      <documentation>Pipeline for discovering motifs from ChIP-seq (or ChIP-chip) peak sequences.</documentation>
      <input name="PeakMotifsRequest" message="tns:peak_motifsRequest"/>
      <output name="PeakMotifsResponse" message="tns:peak_motifsResponse"/>
    </operation>
    <operation name="dyad_analysis">
      <documentation>Analysis of the statistical significance of all the spaced dyads of a given size in a sequence. Commonly used to detect over-represented spaced dyads in a set of promoter sequences.</documentation>
      <input name="DyadAnalysisRequest" message="tns:dyad_analysisRequest"/>
      <output name="DyadAnalysisResponse" message="tns:dyad_analysisResponse"/>
    </operation>
    <operation name="position_analysis">
      <documentation>Calculates the positional distribution of oligonucleotides in a set of sequences, and detects those which significantly discard from a homogeneous distribution.</documentation>
      <input name="PositionAnalysisRequest" message="tns:position_analysisRequest"/>
      <output name="PositionAnalysisResponse" message="tns:position_analysisResponse"/>
    </operation>
    <operation name="pattern_assembly">
      <documentation>Assemble a set of oligonucleotides or dyads into groups of overlapping patterns (assemblies).</documentation>
      <input name="PatternAssemblyRequest" message="tns:pattern_assemblyRequest"/>
      <output name="PatternAssemblyResponse" message="tns:pattern_assemblyResponse"/>
    </operation>
    <operation name="dna_pattern">
      <documentation>Searches all occurrences of a pattern within DNA sequences.</documentation>
      <input name="DnaPatternRequest" message="tns:dna_patternRequest"/>
      <output name="DnaPatternResponse" message="tns:dna_patternResponse"/>
    </operation>
    <operation name="convert_features">
      <documentation>Interconversions between various formats of feature description.</documentation>
      <input name="ConvertFeaturesRequest" message="tns:convert_featuresRequest"/>
      <output name="ConvertFeaturesResponse" message="tns:convert_featuresResponse"/>
    </operation>
    <operation name="feature_map">
      <documentation>Draws a graphical map of features (e.g. results of pattern matching) in a set of sequences.</documentation>
      <input name="FeatureMapRequest" message="tns:feature_mapRequest"/>
      <output name="FeatureMapResponse" message="tns:feature_mapResponse"/>
    </operation>
    <operation name="footprint_discovery">
      <documentation>Detect phylogenetic footprints by applying dyad-analysis in promoters of a set of orthologous genes.</documentation>
      <input name="FootprintDiscoveryRequest" message="tns:footprint_discoveryRequest"/>
      <output name="FootprintDiscoveryResponse" message="tns:footprint_discoveryResponse"/>
    </operation>
    <operation name="get_orthologs">
      <documentation>Get orthologuous genes.</documentation>
      <input name="GetOrthologsRequest" message="tns:get_orthologsRequest"/>
      <output name="GetOrthologsResponse" message="tns:get_orthologsResponse"/>
    </operation>
    <operation name="infer_operon">
      <documentation>Infer operon.</documentation>
      <input name="InferOperonRequest" message="tns:infer_operonRequest"/>
      <output name="InferOperonResponse" message="tns:infer_operonResponse"/>
    </operation>
    <operation name="gene_info">
      <documentation>Get information about genes.</documentation>
      <input name="GeneInfoRequest" message="tns:gene_infoRequest"/>
      <output name="GeneInfoResponse" message="tns:gene_infoResponse"/>
    </operation>
    <operation name="supported_organisms">
      <documentation>List RSAT suppported organisms.</documentation>
      <input name="SupportedOrganismsRequest" message="tns:supported_organismsRequest"/>
      <output name="SupportedOrganismsResponse" message="tns:supported_organismsResponse"/>
    </operation>
    <operation name="supported_motif_databases">
      <documentation>List RSAT suppported motif databases.</documentation>
      <input name="SupportedMotifDatabasesRequest" message="tns:supported_motif_databasesRequest"/>
      <output name="SupportedMotifDatabasesResponse" message="tns:supported_motif_databasesResponse"/>
    </operation>
    <operation name="text_to_html">
      <documentation>Converts a tab-delimited file into a HTML table</documentation>
      <input name="TextToHtmlRequest" message="tns:text_to_htmlRequest"/>
      <output name="TextToHtmlResponse" message="tns:text_to_htmlResponse"/>
    </operation>
    <operation name="parse_psi_xml">
      <documentation>Converts a psi xml file in a tab delimited file</documentation>
      <input name="ParsePsiXmlRequest" message="tns:parse_psi_xmlRequest"/>
      <output name="ParsePsiXmlResponse" message="tns:parse_psi_xmlResponse"/>
    </operation>
    <operation name="roc_stats">
      <documentation>Computes, from a set of scored results associated with validation labels, the derived statistics (Sn, PPV, FPR), which can be further used to draw a ROC curve.</documentation>
      <input name="RocStatsRequest" message="tns:roc_statsRequest"/>
      <output name="RocStatsResponse" message="tns:roc_statsResponse"/>
    </operation>
    <operation name="xygraph">
      <documentation>Plot a graph and export it.</documentation>
      <input name="XYGraphRequest" message="tns:xy_graphRequest"/>
      <output name="XYGraphResponse" message="tns:xy_graphResponse"/>
    </operation>
    <operation name="classfreq">
      <documentation>This script takes a group of numbers (real or integers) and outputs their distribution among classes.</documentation>
      <input name="ClassFreqRequest" message="tns:class_freqRequest"/>
      <output name="ClassFreqResponse" message="tns:class_freqResponse"/>
    </operation>
    <operation name="convert_seq">
      <documentation>Converts a sequence between two formats (e.g. fasta -> raw).</documentation>
      <input name="ConvertSeqRequest" message="tns:convert_seqRequest"/>
      <output name="ConvertSeqResponse" message="tns:convert_seqResponse"/>
    </operation>
    <operation name="compare_classes">
      <documentation>Compare two class files(the query file and the reference file). Each class of the query file is compared to each class of the reference file. The number of common elements is reported, as well as the probability to observe at least this number of common elements by chance alone.</documentation>
      <input name="CompareClassesRequest" message="tns:compare_classesRequest"/>
      <output name="CompareClassesResponse" message="tns:compare_classesResponse"/>
    </operation>
    <operation name="convert_classes">
      <documentation>Interconversions between different formats of cluster files.</documentation>
      <input name="ConvertClassesRequest" message="tns:convert_classesRequest"/>
      <output name="ConvertClassesResponse" message="tns:convert_classesResponse"/>
    </operation>
    <operation name="contingency_stats">
      <documentation>This programs takes as input a contingency table, and calculates various     matching statistics between the rows and columns. The description of these statistics can be found in Brohee and van Helden (2006).</documentation>
      <input name="ContingencyStatsRequest" message="tns:contingency_statsRequest"/>
      <output name="ContingencyStatsResponse" message="tns:contingency_statsResponse"/>
    </operation>
    <operation name="contingency_table">
      <documentation> Create a contingency table from a two-column file.</documentation>
      <input name="ContingencyTableRequest" message="tns:contingency_tableRequest"/>
      <output name="ContingencyTableResponse" message="tns:contingency_tableResponse"/>
    </operation>
    <operation name="compare_matrices">
      <documentation>Compare two collections of position-specific scoring matrices (PSSM), and return various similarity statistics + matrix alignments (pairwise, one-to-n).</documentation>
      <input name="CompareMatricesRequest" message="tns:compare_matricesRequest"/>
      <output name="CompareMatricesResponse" message="tns:compare_matricesResponse"/>
    </operation>
    <operation name="matrix_scan">
      <documentation>Scan sequences with one or several position-specific scoring matrices (PSSM) to identify instances of the corresponding motifs(putative sites). This program supports a variety of background models (Bernoulli, Markov chains of any order).</documentation>
      <input name="MatrixScanRequest" message="tns:matrix_scanRequest"/>
      <output name="MatrixScanResponse" message="tns:matrix_scanResponse"/>
    </operation>
    <operation name="convert_matrix">
      <documentation>Performs inter-conversions between various formats of position-specific scoring matrices (PSSM). The program also performs a statistical analysis of the original matrix to provide different position-specific scores (weight, frequencies, information contents), general statistics (E-value, total information content), and synthetic descriptions (consensus).</documentation>
      <input name="ConvertMatrixRequest" message="tns:convert_matrixRequest"/>
      <output name="ConvertMatrixResponse" message="tns:convert_matrixResponse"/>
    </operation>
    <operation name="matrix_distrib">
      <documentation>Returns the theoretical distribution of matrix weight within the defined background model.</documentation>
      <input name="MatrixDistribRequest" message="tns:matrix_distribRequest"/>
      <output name="MatrixDistribResponse" message="tns:matrix_distribResponse"/>
    </operation>
    <operation name="random_seq">
      <documentation>Generates random sequences.</documentation>
      <input name="RandomSequenceRequest" message="tns:random_seqRequest"/>
      <output name="RandomSequenceResponse" message="tns:random_seqResponse"/>
    </operation>
    <operation name="fetch_sequences">
      <documentation>Returns DNA sequences for list of coordinates in BED format.</documentation>
      <input name="FetchSequencesRequest" message="tns:fetch_sequencesRequest"/>
      <output name="FetchSequencesResponse" message="tns:fetch_sequencesResponse"/>         
    </operation>

    <!-- NeA TOOLS PORTTYPES -->
    <operation name="convert_graph">
      <documentation>Convert graphs between different formats</documentation>
      <input name="ConvertGraphRequest" message="tns:convert_graphRequest"/>
      <output name="ConvertGraphResponse" message="tns:convert_graphResponse"/>         
    </operation>
    <operation name="alter_graph">
      <documentation>Alter a graph either by adding or removing edges or nodes</documentation>
      <input name="AlterGraphRequest" message="tns:alter_graphRequest"/>
      <output name="AlterGraphResponse" message="tns:alter_graphResponse"/>         
    </operation>
    <operation name="graph_cliques">
      <documentation>Find all cliques in a graph</documentation>
      <input name="GraphCliquesRequest" message="tns:graph_cliquesRequest"/>
      <output name="GraphCliquesResponse" message="tns:graph_cliquesResponse"/>         
    </operation>
    <operation name="display_graph">
      <documentation>Produces the figure of a graph</documentation>
      <input name="DisplayGraphRequest" message="tns:display_graphRequest"/>
      <output name="DisplayGraphResponse" message="tns:display_graphResponse"/>         
    </operation>
    <operation name="draw_heatmap">
      <documentation>Produces the figure of a heatmap</documentation>
      <input name="DrawHeatmapRequest" message="tns:draw_heatmapRequest"/>
      <output name="DrawHeatmapResponse" message="tns:draw_heatmapResponse"/>         
    </operation>
    <operation name="compare_graphs">
      <documentation>Computes the union / difference or intersection of two graphs</documentation>
      <input name="CompareGraphsRequest" message="tns:compare_graphsRequest"/>
      <output name="CompareGraphsResponse" message="tns:compare_graphsResponse"/>         
    </operation>
    <operation name="graph_node_degree">
      <documentation>Calculates the in / out / global degree for a selection of seed nodes</documentation>
      <input name="GraphNodeDegreeRequest" message="tns:graph_node_degreeRequest"/>
      <output name="GraphNodeDegreeResponse" message="tns:graph_node_degreeResponse"/>         
    </operation>
    <operation name="graph_topology">
      <documentation>Calculate the node degree, the closeness and the betweenness of each node and specifies if this node is a seed or a target node.</documentation>
      <input name="GraphTopologyRequest" message="tns:graph_topologyRequest"/>
      <output name="GraphTopologyResponse" message="tns:graph_topologyResponse"/>         
    </operation>
    <operation name="graph_cluster_membership">
      <documentation>Map a clustering result onto a graph, and compute the membership degree between each node and each cluster, on the basis of egdes linking this node to the cluster.</documentation>
      <input name="GraphClusterMembershipRequest" message="tns:graph_cluster_membershipRequest"/>
      <output name="GraphClusterMembershipResponse" message="tns:graph_cluster_membershipResponse"/>         
    </operation>
    <operation name="random_graph">
      <documentation>Generate random graphs either from scratch of from an existing graph using different randomization models</documentation>
      <input name="RandomGraphRequest" message="tns:random_graphRequest"/>
      <output name="RandomGraphResponse" message="tns:random_graphResponse"/>         
    </operation>	
    <operation name="graph_get_clusters">
      <documentation>Compares a graph with a classification/clustering file.</documentation>
      <input name="GraphGetClustersRequest" message="tns:graph_get_clustersRequest"/>
      <output name="GraphGetClustersResponse" message="tns:graph_get_clustersResponse"/>         
    </operation>
    <operation name="graph_neighbours">
      <documentation>Find the neihbours up to a certain distance of a collection of seed nodes</documentation>
      <input name="GraphNeighboursRequest" message="tns:graph_neighboursRequest"/>
      <output name="GraphNeighboursResponse" message="tns:graph_neighboursResponse"/>         
    </operation>
    <operation name="mcl">
      <documentation>Clustering via Stijn van Dongen MCL algorithm</documentation>
      <input name="MCLRequest" message="tns:mclRequest"/>
      <output name="MCLResponse" message="tns:mclResponse"/>         
    </operation>
    <operation name="rnsc">
      <documentation>Clustering via Andrew King RNSC algorithm</documentation>
      <input name="RNSCRequest" message="tns:r_n_s_cRequest"/>
      <output name="RNSCResponse" message="tns:r_n_s_cResponse"/>
    </operation>

    <!-- GENERAL UTILITY TOOLS PORTTYPES -->
    <operation name="monitor">
      <documentation>Monitoring the status of a job</documentation>
      <input name="MonitorRequest" message="tns:monitorRequest"/>
      <output name="MonitorResponse" message="tns:monitorResponse"/>         
    </operation>
    <operation name="get_result">
      <documentation>Get result of a job</documentation>
      <input name="GetResultRequest" message="tns:get_resultRequest"/>
      <output name="GetResultResponse" message="tns:get_resultResponse"/>         
    </operation>
  </portType>

  <binding name="RSATWSBinding" type="tns:RSATWSPortType">
    <!-- RSA TOOLS BINDINGS -->
    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
    <operation name="retrieve_seq">
      <soap:operation soapAction=""/>
      <input name="RetrieveSequenceRequest">
        <soap:body use="literal" />
      </input>
      <output name="RetrieveSequenceResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="retrieve_seq_multigenome">
      <soap:operation soapAction=""/>
      <input name="RetrieveSequenceMultigenomeRequest">
        <soap:body use="literal" />
      </input>
      <output name="RetrieveSequenceMultigenomeResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="retrieve_ensembl_seq">
      <soap:operation soapAction=""/>
      <input name="RetrieveEnsemblSequenceRequest">
        <soap:body use="literal" />
      </input>
      <output name="RetrieveEnsemblSequenceResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="purge_seq">
      <soap:operation soapAction=""/>
      <input  name="PurgeSequenceRequest">
        <soap:body use="literal" />
      </input>
      <output name="PurgeSequenceResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="oligo_analysis">
      <soap:operation soapAction=""/>
      <input name="OligoAnalysisRequest">
        <soap:body use="literal" />
      </input>
      <output name="OligoAnalysisResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="oligo_diff">
      <soap:operation soapAction=""/>
      <input name="OligoDiffRequest">
        <soap:body use="literal" />
      </input>
      <output name="OligoDiffResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="peak_motifs">
      <soap:operation soapAction=""/>
      <input name="PeakMotifsRequest">
        <soap:body use="literal" />
      </input>
      <output name="PeakMotifsResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="dyad_analysis">
      <soap:operation soapAction=""/>
      <input name="DyadAnalysisRequest">
        <soap:body use="literal" />
      </input>
      <output name="DyadAnalysisResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="position_analysis">
      <soap:operation soapAction=""/>
      <input name="PositionAnalysisRequest">
        <soap:body use="literal" />
      </input>
      <output name="PositionAnalysisResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="pattern_assembly">
      <soap:operation soapAction=""/>
      <input name="PatternAssemblyRequest">
        <soap:body use="literal" />
      </input>
      <output name="PatternAssemblyResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="dna_pattern">
      <soap:operation soapAction=""/>
      <input name="DnaPatternRequest">
        <soap:body use="literal" />
      </input>
      <output name="DnaPatternResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="convert_features">
      <soap:operation soapAction=""/>
      <input name="ConvertFeaturesRequest">
        <soap:body use="literal" />
      </input>
      <output name="ConvertFeaturesResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="feature_map">
      <soap:operation soapAction=""/>
      <input name="FeatureMapRequest">
        <soap:body use="literal" />
      </input>
      <output name="FeatureMapResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="footprint_discovery">
      <soap:operation soapAction=""/>
      <input name="FootprintDiscoveryRequest">
        <soap:body use="literal" />
      </input>
      <output name="FootprintDiscoveryResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="get_orthologs">
      <soap:operation soapAction=""/>
      <input name="GetOrthologsRequest">
        <soap:body use="literal" />
      </input>
      <output name="GetOrthologsResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="infer_operon">
      <soap:operation soapAction=""/>
      <input name="InferOperonRequest">
        <soap:body use="literal" />
      </input>
      <output name="InferOperonResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="gene_info">
      <soap:operation soapAction=""/>
      <input name="GeneInfoRequest">
        <soap:body use="literal" />
      </input>
      <output name="GeneInfoResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="supported_organisms">
      <soap:operation soapAction=""/>
      <input name="SupportedOrganismsRequest">
        <soap:body use="literal" />
      </input>
      <output name="SupportedOrganismsResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="supported_motif_databases">
      <soap:operation soapAction=""/>
      <input name="SupportedMotifDatabasesRequest">
        <soap:body use="literal" />
      </input>
      <output name="SupportedMotifDatabasesResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="text_to_html">
      <soap:operation soapAction=""/>
      <input name="TextToHtmlRequest">
        <soap:body use="literal" />
      </input>
      <output name="TextToHtmlResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="parse_psi_xml">
      <soap:operation soapAction=""/>
      <input name="ParsePsiXmlRequest">
        <soap:body use="literal" />
      </input>
      <output name="ParsePsiXmlResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="roc_stats">
      <soap:operation soapAction=""/>
      <input name="RocStatsRequest">
        <soap:body use="literal" />
      </input>
      <output name="RocStatsResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="classfreq">
      <soap:operation soapAction=""/>
      <input name="ClassFreqRequest">
        <soap:body use="literal" />
      </input>
      <output name="ClassFreqResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="xygraph">
      <soap:operation soapAction=""/>
      <input name="XYGraphRequest">
        <soap:body use="literal" />
      </input>
      <output name="XYGraphResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="convert_seq">
      <soap:operation soapAction=""/>
      <input name="ConvertSeqRequest">
        <soap:body use="literal" />
      </input>
      <output name="ConvertSeqResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="compare_classes">
      <soap:operation soapAction=""/>
      <input name="CompareClassesRequest">
        <soap:body use="literal" />
      </input>
      <output name="CompareClassesResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="convert_classes">
      <soap:operation soapAction=""/>
      <input name="ConvertClassesRequest">
        <soap:body use="literal" />
      </input>
      <output name="ConvertClassesResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="contingency_stats">
      <soap:operation soapAction=""/>
      <input name="ContingencyStatsRequest">
        <soap:body use="literal" />
      </input>
      <output name="ContingencyStatsResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="contingency_table">
      <soap:operation soapAction=""/>
      <input name="ContingencyTableRequest">
        <soap:body use="literal" />
      </input>
      <output name="ContingencyTableResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="compare_matrices">
      <soap:operation soapAction=""/>
      <input name="CompareMatricesRequest">
        <soap:body use="literal" />
      </input>
      <output name="CompareMatricesResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="matrix_scan">
      <soap:operation soapAction=""/>
      <input name="MatrixScanRequest">
        <soap:body use="literal" />
      </input>
      <output name="MatrixScanResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="convert_matrix">
      <soap:operation soapAction=""/>
      <input name="ConvertMatrixRequest">
        <soap:body use="literal" />
      </input>
      <output name="ConvertMatrixResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="matrix_distrib">
      <soap:operation soapAction=""/>
      <input name="MatrixDistribRequest">
        <soap:body use="literal" />
      </input>
      <output name="MatrixDistribResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="random_seq">
      <soap:operation soapAction=""/>
      <input name="RandomSequenceRequest">
        <soap:body use="literal" />
      </input>
      <output name="RandomSequenceResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="fetch_sequences">
      <soap:operation soapAction=""/>
      <input name="FetchSequencesRequest">
        <soap:body use="literal" />
      </input>
      <output name="FetchSequencesResponse">
        <soap:body use="literal" />
      </output>
    </operation>

    <!-- NeA TOOLS BINDINGS -->
    <operation name="convert_graph">
      <soap:operation soapAction=""/>
      <input name="ConvertGraphRequest">
        <soap:body use="literal" />
      </input>
      <output name="ConvertGraphResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="alter_graph">
      <soap:operation soapAction=""/>
      <input name="AlterGraphRequest">
        <soap:body use="literal" />
      </input>
      <output name="AlterGraphResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="graph_cliques">
      <soap:operation soapAction=""/>
      <input name="GraphCliquesRequest">
        <soap:body use="literal" />
      </input>
      <output name="GraphCliquesResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="display_graph">
      <soap:operation soapAction=""/>
      <input name="DisplayGraphRequest">
        <soap:body use="literal" />
      </input>
      <output name="DisplayGraphResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="draw_heatmap">
      <soap:operation soapAction=""/>
      <input name="DrawHeatmapRequest">
        <soap:body use="literal" />
      </input>
      <output name="DrawHeatmapResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="compare_graphs">
      <soap:operation soapAction=""/>
      <input name="CompareGraphsRequest">
        <soap:body use="literal" />
      </input>
      <output name="CompareGraphsResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="graph_neighbours">
      <soap:operation soapAction=""/>
      <input name="GraphNeighboursRequest">
        <soap:body use="literal" />
      </input>
      <output name="GraphNeighboursResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="mcl">
      <soap:operation soapAction=""/>
      <input name="MCLRequest">
        <soap:body use="literal" />
      </input>
      <output name="MCLResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="rnsc">
      <soap:operation soapAction=""/>
      <input name="RNSCRequest">
        <soap:body use="literal" />
      </input>
      <output name="RNSCResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="graph_node_degree">
      <soap:operation soapAction=""/>
      <input name="GraphNodeDegreeRequest">
        <soap:body use="literal" />
      </input>
      <output name="GraphNodeDegreeResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="graph_topology">
      <soap:operation soapAction=""/>
      <input name="GraphTopologyRequest">
        <soap:body use="literal" />
      </input>
      <output name="GraphTopologyResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="graph_cluster_membership">
      <soap:operation soapAction=""/>
      <input name="GraphClusterMembershipRequest">
        <soap:body use="literal" />
      </input>
      <output name="GraphClusterMembershipResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="graph_get_clusters">
      <soap:operation soapAction=""/>
      <input name="GraphGetClustersRequest">
        <soap:body use="literal" />
      </input>
      <output name="GraphGetClustersResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="random_graph">
      <soap:operation soapAction=""/>
      <input name="RandomGraphRequest">
        <soap:body use="literal" />
      </input>
      <output name="RandomGraphResponse">
        <soap:body use="literal" />
      </output>
    </operation>

    <!-- GENERAL UTILITY TOOLS BINDINGS -->
    <operation name="monitor">
      <soap:operation soapAction=""/>
      <input name="MonitorRequest">
        <soap:body use="literal" />
      </input>
      <output name="MonitorResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="get_result">
      <soap:operation soapAction=""/>
      <input name="GetResultRequest">
        <soap:body use="literal" />
      </input>
      <output name="GetResultResponse">
        <soap:body use="literal" />
      </output>
    </operation>
  </binding>

  <service name="RSATWebServices">
    <documentation>Web services for the Regulatory Sequence Analysis Tools (RSAT). Tools developed by Jacques van Helden (jvanheld@bigre.ulb.ac.be), SOAP/WSDL interface developed by Olivier Sand (oly@bigre.ulb.ac.be).</documentation>
    <port name="RSATWSPortType" binding="tns:RSATWSBinding">
       <soap:address location="http://rsat.sb-roscoff.fr/web_services/RSATWS.cgi"/>
<!--       <soap:address location="http://rsat.ulb.ac.be/rsat/web_services/RSATWS.cgi"/>-->
<!--       <soap:address location="http://localhost/rsat/web_services/RSATWS.cgi"/>-->
    </port>
  </service>
</definitions>
